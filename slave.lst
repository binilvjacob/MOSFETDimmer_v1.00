CCS PCM C Compiler, Version 5.015, 5967               02-May-22 14:10

               Filename:   D:\namami-li\LiHome\MOSFET DRIVER pic code\SLAVE 684 - beta v1.01\slave.lst

               ROM used:   1994 words (97%)
                           Largest free fragment is 54
               RAM used:   70 (55%) at main() level
                           87 (68%) worst case
               Stack used: 5 locations (3 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  06
0001:  MOVWF  0A
0002:  GOTO   6A2
0003:  NOP
0004:  BTFSC  03.5
0005:  GOTO   00A
0006:  MOVWF  24
0007:  SWAPF  03,W
0008:  MOVWF  25
0009:  GOTO   00F
000A:  BCF    03.5
000B:  MOVWF  24
000C:  SWAPF  03,W
000D:  MOVWF  25
000E:  BSF    25.1
000F:  MOVF   0A,W
0010:  MOVWF  2B
0011:  CLRF   0A
0012:  BCF    03.7
0013:  SWAPF  24,F
0014:  MOVF   04,W
0015:  MOVWF  26
0016:  MOVF   20,W
0017:  MOVWF  27
0018:  MOVF   21,W
0019:  MOVWF  28
001A:  MOVF   22,W
001B:  MOVWF  29
001C:  MOVF   23,W
001D:  MOVWF  2A
001E:  BCF    03.5
001F:  BTFSS  0B.5
0020:  GOTO   023
0021:  BTFSC  0B.2
0022:  GOTO   13E
0023:  BTFSS  0B.4
0024:  GOTO   027
0025:  BTFSC  0B.1
0026:  GOTO   040
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.0
002A:  GOTO   02D
002B:  BTFSC  0C.0
002C:  GOTO   076
002D:  MOVF   26,W
002E:  MOVWF  04
002F:  MOVF   27,W
0030:  MOVWF  20
0031:  MOVF   28,W
0032:  MOVWF  21
0033:  MOVF   29,W
0034:  MOVWF  22
0035:  MOVF   2A,W
0036:  MOVWF  23
0037:  MOVF   2B,W
0038:  MOVWF  0A
0039:  SWAPF  25,W
003A:  MOVWF  03
003B:  BCF    03.5
003C:  SWAPF  24,W
003D:  BTFSC  25.1
003E:  BSF    03.5
003F:  RETFIE
....................  
.................... 								// MOSFET DIMMABLE DRIVER VERSION 1 BETA v1.00 // 
.................... /*  
.................... 	   Details :  
....................  
.................... 	-> Faderate concept removed to execute over current shutdown 
.................... 	-> PWM auto shutdown enabled 
.................... 	-> PWM auto restart disabled 
.................... 	-> PWM restart delay increments sequentially 
.................... 	-> Hardware relay connected to PIN_C2 
.................... 	-> Comparator 2 with inverted output is used 
.................... 	-> CCP1 module is used in PWM mode 
.................... 	-> Device type ID : 7 
.................... 	-> DALI Tx pin : PIN_A0 
.................... 	-> DALI Rx pin : PIN_A2 
.................... 	-> Version : BETA 
.................... 	-> Last modified date : 30/04/2022     
.................... 	-> Github repo URL :  https://github.com/binilvjacob/MOSFETDimmer_v1.00 
....................  
.................... */ 
....................   
....................  
.................... #include <slave.h> 
.................... #include <16F684.h> 
.................... //////////// Standard Header file for the PIC16F684 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F684 
*
027D:  MOVLW  20
027E:  MOVWF  70
027F:  CLRF   6C
0280:  CLRF   6D
0281:  CLRF   6E
0282:  CLRF   6F
0283:  MOVF   67,W
0284:  MOVWF  23
0285:  MOVF   66,W
0286:  MOVWF  22
0287:  MOVF   65,W
0288:  MOVWF  21
0289:  MOVF   64,W
028A:  MOVWF  20
028B:  BCF    03.0
028C:  BTFSS  20.0
028D:  GOTO   29C
028E:  MOVF   68,W
028F:  ADDWF  6C,F
0290:  MOVF   69,W
0291:  BTFSC  03.0
0292:  INCFSZ 69,W
0293:  ADDWF  6D,F
0294:  MOVF   6A,W
0295:  BTFSC  03.0
0296:  INCFSZ 6A,W
0297:  ADDWF  6E,F
0298:  MOVF   6B,W
0299:  BTFSC  03.0
029A:  INCFSZ 6B,W
029B:  ADDWF  6F,F
029C:  RRF    6F,F
029D:  RRF    6E,F
029E:  RRF    6D,F
029F:  RRF    6C,F
02A0:  RRF    23,F
02A1:  RRF    22,F
02A2:  RRF    21,F
02A3:  RRF    20,F
02A4:  DECFSZ 70,F
02A5:  GOTO   28B
02A6:  GOTO   742 (RETURN)
....................  
.................... #list 
....................  
....................  
.................... #device adc=8 
....................  
.................... #FUSES WDT                 		// Watch Dog Timer 
.................... #FUSES INTRC_IO                 //Crystal osc <= 4mhz for PCM/PCH , 3mhz to 10 mhz for PCD 
.................... //#FUSES XT 
.................... #FUSES NOPROTECT             	// Code not protected from reading 
.................... #FUSES BROWNOUT              	// Reset when brownout detected 
.................... #FUSES MCLR                  	// Master Clear pin enabled 
.................... #FUSES NOCPD                 	// No EE protection 
.................... #FUSES PUT                 		// Power Up Timer 
.................... #FUSES NOIESO                	// Internal External Switch Over mode disabled 
.................... #FUSES NOFCMEN               	// Fail-safe clock monitor disabled 
....................  
.................... #use delay(clock=4000000) 
....................  
.................... #include<math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
06CA:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #use delay(clock=4000000) 
*
0302:  MOVLW  12
0303:  SUBWF  67,F
0304:  BTFSS  03.0
0305:  GOTO   314
0306:  MOVLW  67
0307:  MOVWF  04
0308:  MOVLW  FC
0309:  ANDWF  00,F
030A:  BCF    03.0
030B:  RRF    00,F
030C:  RRF    00,F
030D:  MOVF   00,W
030E:  BTFSC  03.2
030F:  GOTO   314
0310:  GOTO   312
0311:  NOP
0312:  DECFSZ 00,F
0313:  GOTO   311
*
068D:  MOVLW  64
068E:  MOVWF  04
068F:  MOVF   00,W
0690:  BTFSC  03.2
0691:  GOTO   6A0
0692:  MOVLW  01
0693:  MOVWF  21
0694:  CLRF   20
0695:  DECFSZ 20,F
0696:  GOTO   695
0697:  DECFSZ 21,F
0698:  GOTO   694
0699:  MOVLW  4A
069A:  MOVWF  20
069B:  DECFSZ 20,F
069C:  GOTO   69B
069D:  GOTO   69E
069E:  DECFSZ 00,F
069F:  GOTO   692
....................  
.................... #define device_type 7  				// setting device type 7 - MOSFET dimamble driver 
....................  
.................... #define Fixlampid   9 				// LAMP ADDRESS // 
.................... #define zoneid_init   212 			// zone address //  
.................... #define G1 0b00000001 
.................... #define G2 0b00000000 
.................... #define rx pin_a2 
.................... #define tx pin_a0 
.................... #define self 0x01 
....................  
.................... #define MaxDuty  100  
.................... #define MinDuty  0 
....................  
.................... /////////////////////////////////////////////////////////////// 
....................  
.................... #define PowerOnLevelStore    		0        	// Latest power level    
.................... #define MinimumLevelStore           1			// Minimum allowable power level 
.................... #define MaximumLevelStore  			2 			// Maximum allowable power level 
.................... #define ShortAddressStore  			3  			// Unique device ID 
.................... #define Group_07Store    			4			// First byte of group 
.................... #define Group_815Store  			5			// Second byte of group 
.................... #define SceneStore  				6			// 6-21 Scene level store 
.................... #define ZoneIDStore 				32			// Zone ID 
.................... #define SystemFailureRateStore 		33			// Number of times over current shutdown was detected 
.................... #define CurrentThresholdStore 		34			// To store current protection threshold value 
....................  
.................... ////////////////// Device types //////////////////////// 
.................... /* 
.................... 	lamp =1 
.................... 	fan=2 
.................... 	curtain=3 
.................... 	strip=4 
.................... 	mosfet dimamble driver = 7 
.................... */ 
.................... //////////////////////////////////////////////////////// 
....................  
.................... #bit PRSEN     = 0x16.7   // PWM autorestart control bit 
.................... #bit CCMCON0 = 0x019.5	  // Comparator output invert bit 
.................... #bit ECCPASE = 0x017.7	  // PWM shutdown event status bit 
....................  
.................... #byte dutyreg = 0x15 
....................   
.................... #bit intf = 0x0b.1 
.................... #bit timerOnOff =0x10.0 
....................  
.................... int1 oddevenbit,a,atmp,b,error_flag,over_flowflag; 
.................... unsigned int8 dataCount; 
.................... char data[3],bitcount,tout; 
.................... unsigned char duty; 
....................  
.................... unsigned int16 power; 
....................  
.................... char settling_time,i,dly=4,j; 
.................... int1 txmit_error=0; 
.................... char tx_buffer[3]; 
.................... char r_a,currentSceen; 
.................... char l_st; 
.................... char command_st,RetryCount; 
....................  
.................... char zoneid=zoneid_init; 
....................  
.................... char stopBitCount,address ,command,databyte; 
.................... int1 dataready,forwrdFrameFlag,backwardFrameFlag ,masterFlag ; 
.................... int16 readDly=300; 
.................... int16 GroupSelectReg; 
.................... char gindex; 
....................  
.................... /////// new  ////// 
.................... int txmit_count=0; 
.................... /////////////////// 
....................  
.................... char MinimumLevel; 
.................... char MaximumLevel; 
.................... char PowerOnLevel; 
.................... char DTR,DwriteLocation,DTR_Ready; 
....................  
.................... char lampid  = Fixlampid; 
....................  
.................... int1 reset_flag=0;			// For WDT reset operation inside RTCC interrupt 
....................  
.................... int32 restart_count=0; 
.................... int32 restart_delay=0; 
.................... char failure_count=0; 
.................... char current_threshold=1; 
....................  
.................... void readData(void); 
.................... void init(void); 
.................... void handle(void ); 
.................... void copyData(void); 
.................... void commands(void); 
.................... void txmit(char priority,char length); 
.................... void txmit1(void); 
.................... void txmit0(void); 
.................... void stopbit(void); 
.................... void lamp_on(void); 
.................... void lamp_off(void); 
.................... void startBit(void); 
.................... void init_from_eeprom(void); 
.................... void SetDimmLevel(unsigned int dimPesentage); 
....................  
....................  
.................... #rom  0x2100={MaxDuty,MinDuty,MaxDuty,Fixlampid,G1,G2,0,20,30,50,70,90,100,35,40,45,75,25,60,65,95,100} 
....................  
.................... #rom  0x2120={zoneid_init,0,1} 
....................  
.................... #int_EXT 
.................... EXT_isr()  
.................... { 
.................... 			clear_interrupt(int_ext); 
*
0040:  BCF    0B.1
....................             disable_interrupts(int_ext); 
0041:  BCF    0B.4
....................             disable_interrupts(INT_RTCC); 
0042:  BCF    0B.5
....................             bitcount=0; 
0043:  CLRF   36
....................             setup_timer_1(T1_internal|T1_div_by_1); 
0044:  MOVLW  05
0045:  MOVWF  10
....................             set_timer1(0xffff-840); //858  880///old value 923 
0046:  CLRF   0E
0047:  MOVLW  FC
0048:  MOVWF  0F
0049:  MOVLW  B7
004A:  MOVWF  0E
....................             enable_interrupts(int_timer1); 
004B:  BSF    03.5
004C:  BSF    0C.0
....................             stopBitCount = 0; 
004D:  BCF    03.5
004E:  CLRF   48
....................             oddevenbit=1; 
004F:  BSF    31.0
....................             data[0]=0; 
0050:  CLRF   33
....................             data[1]=0; 
0051:  CLRF   34
....................             data[2]=0; 
0052:  CLRF   35
....................             tout=0 ; 
0053:  CLRF   37
....................             datacount = 0;    
0054:  CLRF   32
.................... 			settling_time = 0;  
0055:  CLRF   3B
.................... 			return(0); 
0056:  MOVLW  00
0057:  MOVWF  21
.................... } 
....................  
....................  
0058:  BCF    0B.1
0059:  BCF    0A.3
005A:  GOTO   02D
.................... #int_TIMER1 
.................... TIMER1_isr() 
.................... { 
....................  
.................... readDly=20; 
*
0076:  CLRF   4E
0077:  MOVLW  14
0078:  MOVWF  4D
.................... error_flag=0; 
0079:  BCF    31.4
.................... 	if(oddevenbit==1) 
007A:  BTFSS  31.0
007B:  GOTO   0B7
.................... 	{ 
.................... 		a=input(rx);  
007C:  BSF    03.5
007D:  BSF    05.2
007E:  BCF    03.5
007F:  BCF    31.1
0080:  BTFSC  05.2
0081:  BSF    31.1
.................... 		atmp=a ;           
0082:  BCF    31.2
0083:  BTFSC  31.1
0084:  BSF    31.2
.................... 		oddevenbit=0 ; 
0085:  BCF    31.0
.................... 		 
.................... 				if(atmp) 
0086:  BTFSS  31.2
0087:  GOTO   09E
.................... 				{ 
.................... 					while(atmp) 
0088:  BTFSS  31.2
0089:  GOTO   09D
.................... 						{ 
.................... 							atmp=input(rx); 
008A:  BSF    03.5
008B:  BSF    05.2
008C:  BCF    03.5
008D:  BCF    31.2
008E:  BTFSC  05.2
008F:  BSF    31.2
.................... 							if(readDly>0) 
0090:  MOVF   4D,F
0091:  BTFSS  03.2
0092:  GOTO   096
0093:  MOVF   4E,F
0094:  BTFSC  03.2
0095:  GOTO   09B
.................... 								readDly--; 
0096:  MOVF   4D,W
0097:  BTFSC  03.2
0098:  DECF   4E,F
0099:  DECF   4D,F
009A:  GOTO   09C
.................... 							else 
.................... 								atmp=0; 
009B:  BCF    31.2
009C:  GOTO   088
.................... 								 
.................... 						} 
.................... 				}          
009D:  GOTO   0AF
.................... 				else 
.................... 				{ 
.................... 					while(!atmp) 
009E:  BTFSC  31.2
009F:  GOTO   0AF
.................... 						{ 
.................... 							atmp=input(rx); 
00A0:  BSF    03.5
00A1:  BSF    05.2
00A2:  BCF    03.5
00A3:  BCF    31.2
00A4:  BTFSC  05.2
00A5:  BSF    31.2
.................... 							readDly--; 
00A6:  MOVF   4D,W
00A7:  BTFSC  03.2
00A8:  DECF   4E,F
00A9:  DECFSZ 4D,F
.................... 								if(readdly==0) 
00AA:  GOTO   0AE
00AB:  MOVF   4E,F
00AC:  BTFSC  03.2
.................... 									{ 
.................... 									atmp=1; 
00AD:  BSF    31.2
.................... 									}	 
00AE:  GOTO   09E
.................... 						} 
.................... 				} 
....................  
.................... 			setup_timer_1(T1_internal|T1_div_by_1);//settimer1with1us least count 
00AF:  MOVLW  05
00B0:  MOVWF  10
.................... 			set_timer1(0xffff-150);  //374  //  355             350////old value 150 
00B1:  CLRF   0E
00B2:  MOVLW  FF
00B3:  MOVWF  0F
00B4:  MOVLW  69
00B5:  MOVWF  0E
.................... 	} 
00B6:  GOTO   139
.................... 	else 
.................... 	{  
.................... 		b=input(rx) ; // store data line status in the second half 
00B7:  BSF    03.5
00B8:  BSF    05.2
00B9:  BCF    03.5
00BA:  BCF    31.3
00BB:  BTFSC  05.2
00BC:  BSF    31.3
.................... 		oddevenbit=1; 
00BD:  BSF    31.0
.................... 		setup_timer_1(T1_internal|T1_div_by_1); 
00BE:  MOVLW  05
00BF:  MOVWF  10
.................... 		set_timer1(0xffff-350);  // delay  till the next call st to 73 us/////old value 350 
00C0:  CLRF   0E
00C1:  MOVLW  FE
00C2:  MOVWF  0F
00C3:  MOVLW  A1
00C4:  MOVWF  0E
.................... 		readData();  // function  get the dat from the conditions of a and b 
.................... 					 
.................... 	} 
.................... return(0); 
*
0139:  MOVLW  00
013A:  MOVWF  21
.................... } 
....................  
013B:  BCF    0C.0
013C:  BCF    0A.3
013D:  GOTO   02D
.................... #int_RTCC 
.................... RTCC_isr() 
.................... {	 
.................... 	 
.................... 	reset_flag=1; 
013E:  BSF    4C.3
.................... /* 
.................... 	if(FadeRateCount>0) 
.................... 	{ 
.................... 		FadeRateCount--; 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		FadeRateCount=FadeRate; 
.................... 	} 
.................... */ 
.................... 	dly--; 
013F:  DECFSZ 3D,F
....................   	if (dly == 0) 
0140:  GOTO   147
....................   	{	 
....................       dly = 4; 
0141:  MOVLW  04
0142:  MOVWF  3D
....................       if(settling_time < 250) 
0143:  MOVF   3B,W
0144:  SUBLW  F9
0145:  BTFSC  03.0
....................       { 
....................           settling_time++; 
0146:  INCF   3B,F
....................       }               
....................    } 
.................... 	if(ECCPASE==1 && restart_delay>2) // event just occurred and is not ready for reset 
0147:  BTFSS  17.7
0148:  GOTO   15E
0149:  MOVF   61,F
014A:  BTFSS  03.2
014B:  GOTO   156
014C:  MOVF   60,F
014D:  BTFSS  03.2
014E:  GOTO   156
014F:  MOVF   5F,F
0150:  BTFSS  03.2
0151:  GOTO   156
0152:  MOVF   5E,W
0153:  SUBLW  02
0154:  BTFSC  03.0
0155:  GOTO   15E
.................... 		{ 
.................... 			restart_delay--; 
0156:  MOVLW  FF
0157:  ADDWF  5E,F
0158:  BTFSS  03.0
0159:  ADDWF  5F,F
015A:  BTFSS  03.0
015B:  ADDWF  60,F
015C:  BTFSS  03.0
015D:  ADDWF  61,F
.................... 		} 
.................... 	return(0); 
015E:  MOVLW  00
015F:  MOVWF  21
0160:  BCF    0B.2
0161:  BCF    0A.3
0162:  GOTO   02D
.................... } 
....................  
....................  
.................... void main(void) 
*
06A2:  MOVF   03,W
06A3:  ANDLW  1F
06A4:  MOVWF  03
06A5:  MOVLW  61
06A6:  BSF    03.5
06A7:  MOVWF  0F
06A8:  MOVF   0F,W
06A9:  MOVLW  04
06AA:  BCF    03.5
06AB:  MOVWF  3D
06AC:  BCF    31.6
06AD:  MOVLW  D4
06AE:  MOVWF  47
06AF:  MOVLW  01
06B0:  MOVWF  4E
06B1:  MOVLW  2C
06B2:  MOVWF  4D
06B3:  CLRF   52
06B4:  MOVLW  09
06B5:  MOVWF  59
06B6:  BCF    4C.3
06B7:  CLRF   5D
06B8:  CLRF   5C
06B9:  CLRF   5B
06BA:  CLRF   5A
06BB:  CLRF   61
06BC:  CLRF   60
06BD:  CLRF   5F
06BE:  CLRF   5E
06BF:  CLRF   62
06C0:  MOVLW  01
06C1:  MOVWF  63
06C2:  BCF    1F.6
06C3:  MOVLW  00
06C4:  BSF    03.5
06C5:  MOVWF  11
06C6:  BCF    03.5
06C7:  CLRF   1A
06C8:  MOVLW  07
06C9:  MOVWF  19
....................  
.................... { 
.................... 	setup_wdt(WDT_ON); 
*
06CB:  BSF    18.0
.................... 	setup_wdt(WDT_72MS|WDT_TIMES_16);		//~1.1 s reset	 
06CC:  MOVLW  11
06CD:  MOVWF  18
06CE:  MOVLW  0A
06CF:  MOVWF  20
06D0:  CLRF   01
06D1:  MOVLW  81
06D2:  MOVWF  04
06D3:  MOVF   00,W
06D4:  ANDLW  F0
06D5:  IORLW  07
06D6:  MOVWF  00
06D7:  CLRWDT
06D8:  MOVF   00,W
06D9:  ANDLW  F7
06DA:  BTFSC  20.3
06DB:  ANDLW  F0
06DC:  IORWF  20,W
06DD:  MOVWF  00
.................... 	init_from_eeprom(); 
06DE:  CALL   163
.................... 	init();		 
06DF:  GOTO   1DF
.................... 	GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
06E0:  MOVLW  05
06E1:  BSF    03.5
06E2:  MOVWF  1B
06E3:  BCF    1C.7
06E4:  BSF    1C.0
06E5:  MOVF   1A,W
06E6:  BCF    03.5
06E7:  MOVWF  64
06E8:  MOVLW  04
06E9:  BSF    03.5
06EA:  MOVWF  1B
06EB:  BCF    1C.7
06EC:  BSF    1C.0
06ED:  MOVF   1A,W
06EE:  BCF    03.5
06EF:  MOVWF  65
06F0:  MOVF   64,W
06F1:  MOVWF  50
06F2:  MOVF   65,W
06F3:  MOVWF  4F
.................... 	PowerOnLevel = read_EEPROM (PowerOnLevelStore); 
06F4:  BSF    03.5
06F5:  CLRF   1B
06F6:  BCF    1C.7
06F7:  BSF    1C.0
06F8:  MOVF   1A,W
06F9:  BCF    03.5
06FA:  MOVWF  55
.................... 	if(PowerOnLevel<= MinimumLevel) 
06FB:  MOVF   55,W
06FC:  SUBWF  53,W
06FD:  BTFSS  03.0
06FE:  GOTO   706
.................... 	{ 
.................... 		output_low(pin_c2); 
06FF:  BSF    03.5
0700:  BCF    07.2
0701:  BCF    03.5
0702:  BCF    07.2
.................... 		duty=0; 
0703:  CLRF   38
.................... 		lamp_off();				 
0704:  CALL   273
.................... 	} 
0705:  GOTO   710
.................... 	else 
.................... 	{ 
.................... 		output_high(pin_c2); 
0706:  BSF    03.5
0707:  BCF    07.2
0708:  BCF    03.5
0709:  BSF    07.2
.................... 		duty = PowerOnLevel; 
070A:  MOVF   55,W
070B:  MOVWF  38
.................... 		SetDimmLevel(duty);		 
070C:  MOVF   38,W
070D:  MOVWF  64
070E:  CALL   227
.................... 		lamp_on();		 
070F:  CALL   277
.................... 	} 
.................... 	restart_delay=3000;				// initial restart delay 
0710:  CLRF   61
0711:  CLRF   60
0712:  MOVLW  0B
0713:  MOVWF  5F
0714:  MOVLW  B8
0715:  MOVWF  5E
.................... 	restart_count=0;				// initial restart counts 
0716:  CLRF   5D
0717:  CLRF   5C
0718:  CLRF   5B
0719:  CLRF   5A
.................... 	ECCPASE=0;						// Restart operation 
071A:  BCF    17.7
....................  
.................... start: 
....................  
.................... 	if(restart_delay<=2 && ECCPASE==1)			// restart after variable delay 
071B:  MOVF   61,F
071C:  BTFSS  03.2
071D:  GOTO   789
071E:  MOVF   60,F
071F:  BTFSS  03.2
0720:  GOTO   789
0721:  MOVF   5F,F
0722:  BTFSS  03.2
0723:  GOTO   789
0724:  MOVF   5E,W
0725:  SUBLW  02
0726:  BTFSS  03.0
0727:  GOTO   789
0728:  BTFSS  17.7
0729:  GOTO   789
.................... 	{ 
.................... 		ECCPASE=0;								// PWM restart operation 
072A:  BCF    17.7
.................... 		restart_count++;						// Increment restart event counter 
072B:  MOVLW  01
072C:  ADDWF  5A,F
072D:  BTFSC  03.0
072E:  INCF   5B,F
072F:  BTFSC  03.2
0730:  INCF   5C,F
0731:  BTFSC  03.2
0732:  INCF   5D,F
.................... 		restart_delay=restart_delay+restart_count*5000;		// Increasing the restart delay 
0733:  MOVF   5D,W
0734:  MOVWF  67
0735:  MOVF   5C,W
0736:  MOVWF  66
0737:  MOVF   5B,W
0738:  MOVWF  65
0739:  MOVF   5A,W
073A:  MOVWF  64
073B:  CLRF   6B
073C:  CLRF   6A
073D:  MOVLW  13
073E:  MOVWF  69
073F:  MOVLW  88
0740:  MOVWF  68
0741:  GOTO   27D
0742:  MOVF   20,W
0743:  ADDWF  5E,F
0744:  MOVF   21,W
0745:  BTFSC  03.0
0746:  INCFSZ 21,W
0747:  ADDWF  5F,F
0748:  MOVF   22,W
0749:  BTFSC  03.0
074A:  INCFSZ 22,W
074B:  ADDWF  60,F
074C:  MOVF   23,W
074D:  BTFSC  03.0
074E:  INCFSZ 23,W
074F:  ADDWF  61,F
.................... 		if(restart_delay>30000)					// Permanent shutdown after many restart attempts 
0750:  MOVF   61,F
0751:  BTFSS  03.2
0752:  GOTO   761
0753:  MOVF   60,F
0754:  BTFSS  03.2
0755:  GOTO   761
0756:  MOVF   5F,W
0757:  SUBLW  74
0758:  BTFSC  03.0
0759:  GOTO   789
075A:  XORLW  FF
075B:  BTFSS  03.2
075C:  GOTO   761
075D:  MOVF   5E,W
075E:  SUBLW  30
075F:  BTFSC  03.0
0760:  GOTO   789
.................... 		{ 
.................... 			output_low(pin_c2); 
0761:  BSF    03.5
0762:  BCF    07.2
0763:  BCF    03.5
0764:  BCF    07.2
.................... 			failure_count++;					// Failed to turn ON 
0765:  INCF   62,F
.................... 			if(failure_count>254) 
0766:  MOVF   62,W
0767:  SUBLW  FE
0768:  BTFSC  03.0
0769:  GOTO   76C
.................... 			{ 
.................... 				failure_count=254; 
076A:  MOVLW  FE
076B:  MOVWF  62
.................... 			} 
.................... 			write_eeprom(SystemFailureRateStore,failure_count); 
076C:  MOVF   0B,W
076D:  MOVWF  20
076E:  BCF    0B.7
076F:  MOVLW  21
0770:  BSF    03.5
0771:  MOVWF  1B
0772:  BCF    03.5
0773:  MOVF   62,W
0774:  BSF    03.5
0775:  MOVWF  1A
0776:  BCF    1C.7
0777:  BSF    1C.2
0778:  MOVLW  55
0779:  MOVWF  1D
077A:  MOVLW  AA
077B:  MOVWF  1D
077C:  BSF    1C.1
077D:  BTFSC  1C.1
077E:  GOTO   77D
077F:  BCF    1C.2
0780:  BCF    03.5
0781:  MOVF   20,W
0782:  IORWF  0B,F
.................... 			delay_us(10);			 
0783:  MOVLW  02
0784:  MOVWF  20
0785:  DECFSZ 20,F
0786:  GOTO   785
0787:  GOTO   788
0788:  NOP
.................... 		}		 
.................... 	} 
.................... 	 
.................... 	if(reset_flag==1) 
0789:  BTFSS  4C.3
078A:  GOTO   78D
.................... 	{ 
.................... 	restart_wdt();  
078B:  CLRWDT
.................... 	reset_flag=0; 
078C:  BCF    4C.3
.................... 	} 
.................... 		 
.................... 	if (dataReady ==1) 
078D:  BTFSS  31.7
078E:  GOTO   7BB
.................... 	{ 
.................... 		if(address == 0xff) 
078F:  INCFSZ 49,W
0790:  GOTO   793
.................... 		{ 
.................... 			handle();  
0791:  CALL   386
.................... 		}		 
0792:  GOTO   7BA
.................... 		else if(address==lampid)		{ 
0793:  MOVF   59,W
0794:  SUBWF  49,W
0795:  BTFSS  03.2
0796:  GOTO   799
.................... 			 
.................... 			handle();  
0797:  CALL   386
.................... 		}		 
0798:  GOTO   7BA
....................     	else if(address == zoneid) 
0799:  MOVF   47,W
079A:  SUBWF  49,W
079B:  BTFSS  03.2
079C:  GOTO   79F
.................... 		{ 
.................... 			handle();	 
079D:  CALL   386
.................... 		} 
079E:  GOTO   7BA
.................... 		else if(address>191 && address<208) 
079F:  MOVF   49,W
07A0:  SUBLW  BF
07A1:  BTFSC  03.0
07A2:  GOTO   7BA
07A3:  MOVF   49,W
07A4:  SUBLW  CF
07A5:  BTFSS  03.0
07A6:  GOTO   7BA
.................... 		{	 
.................... 			gindex = address &0x0F; 
07A7:  MOVF   49,W
07A8:  ANDLW  0F
07A9:  MOVWF  51
.................... 			if ( bit_test (GroupSelectReg, gindex)==1) 
07AA:  MOVF   50,W
07AB:  MOVWF  23
07AC:  MOVF   4F,W
07AD:  MOVWF  22
07AE:  MOVF   51,W
07AF:  MOVWF  20
07B0:  BTFSC  03.2
07B1:  GOTO   7B7
07B2:  BCF    03.0
07B3:  RRF    23,F
07B4:  RRF    22,F
07B5:  DECFSZ 20,F
07B6:  GOTO   7B2
07B7:  MOVF   22,W
07B8:  BTFSC  22.0
.................... 			{ 				 
.................... 				handle(); 
07B9:  CALL   386
.................... 			}	 
.................... 		} 
.................... 		dataReady =0; 
07BA:  BCF    31.7
.................... 	} 
.................... 	if(txmit_error==1 && txmit_count<5) 
07BB:  BTFSS  31.6
07BC:  GOTO   7C7
07BD:  MOVF   52,W
07BE:  SUBLW  04
07BF:  BTFSS  03.0
07C0:  GOTO   7C7
.................... 	{ 
.................... 		txmit_count++; 
07C1:  INCF   52,F
.................... 		txmit(2,2); 
07C2:  MOVLW  02
07C3:  MOVWF  64
07C4:  MOVWF  65
07C5:  CALL   317
.................... 	}	 
07C6:  GOTO   7C8
.................... 	else 
.................... 	{ 
.................... 		txmit_count=0; 
07C7:  CLRF   52
.................... 	} 
.................... 	 
.................... 	goto start; 
07C8:  GOTO   71B
.................... } 
....................  
07C9:  SLEEP
.................... void init(void) 
....................  
.................... { 
.................... 	setup_timer_2(T2_DIV_BY_1,249,1);		//250 us overflow, 250 us interrupt  // 4000Hz 
*
01DF:  MOVLW  00
01E0:  MOVWF  21
01E1:  IORLW  04
01E2:  MOVWF  12
01E3:  MOVLW  F9
01E4:  BSF    03.5
01E5:  MOVWF  12
.................... 	setup_ccp1(CCP_PWM|CCP_SHUTDOWN_ON_COMP2|CCP_SHUTDOWN_AC_L|CCP_SHUTDOWN_BD_L);	// Setting up PWM 
01E6:  BCF    07.5
01E7:  BCF    03.5
01E8:  BCF    07.5
01E9:  MOVLW  0C
01EA:  MOVWF  15
01EB:  CLRF   16
01EC:  MOVLW  20
01ED:  MOVWF  17
.................... 	setup_comparator(A0_VR_C0_VR);				// Setting up comparator 
01EE:  CLRF   1A
01EF:  MOVLW  0A
01F0:  MOVWF  19
01F1:  BSF    03.5
01F2:  MOVF   05,W
01F3:  IORLW  10
01F4:  MOVWF  05
01F5:  MOVLW  02
01F6:  BCF    03.5
01F7:  MOVWF  20
01F8:  DECFSZ 20,F
01F9:  GOTO   1F8
01FA:  GOTO   1FB
01FB:  NOP
01FC:  MOVF   19,W
01FD:  BCF    0C.3
.................... 	if(current_threshold>15 || current_threshold <1) 
01FE:  MOVF   63,W
01FF:  SUBLW  0F
0200:  BTFSS  03.0
0201:  GOTO   205
0202:  MOVF   63,F
0203:  BTFSS  03.2
0204:  GOTO   207
.................... 	{ 
.................... 		current_threshold=1; 
0205:  MOVLW  01
0206:  MOVWF  63
.................... 	} 
.................... 	setup_vref(VREF_LOW|current_threshold);						// Setting up reference voltage 
0207:  MOVF   63,W
0208:  IORLW  A0
0209:  MOVWF  64
020A:  BSF    03.5
020B:  MOVWF  19
.................... 	PRSEN=0;									// Auto-restart disabled 
020C:  BCF    03.5
020D:  BCF    16.7
.................... 	CCMCON0=1;									// Comparator output inverted 
020E:  BSF    19.5
....................  
.................... 	setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
020F:  BSF    03.5
0210:  MOVF   01,W
0211:  ANDLW  C7
0212:  IORLW  08
0213:  MOVWF  01
.................... 	setup_timer_1(T1_internal|T1_div_by_1); 
0214:  MOVLW  05
0215:  BCF    03.5
0216:  MOVWF  10
.................... 	timerOnOff=0; 
0217:  BCF    10.0
.................... 	clear_interrupt(int_ext); 
0218:  BCF    0B.1
.................... 	ext_int_edge( H_TO_L );	 
0219:  BSF    03.5
021A:  BCF    01.6
.................... 	enable_interrupts(INT_EXT); 
021B:  BCF    03.5
021C:  BSF    0B.4
.................... 	enable_interrupts(INT_RTCC); 
021D:  BSF    0B.5
.................... 	disable_interrupts(INT_TIMER2); 
021E:  BSF    03.5
021F:  BCF    0C.1
.................... 	enable_interrupts(global);	 
0220:  MOVLW  C0
0221:  BCF    03.5
0222:  IORWF  0B,F
.................... 	settling_time =23; 
0223:  MOVLW  17
0224:  MOVWF  3B
.................... 	dataReady =0;   
0225:  BCF    31.7
.................... 	return; 
0226:  GOTO   6E0 (RETURN)
.................... } 
....................  
.................... void handle(void ) 
.................... { 
.................... 	commands(); 
.................... 	delay_ms(2); 
*
068B:  MOVLW  02
068C:  MOVWF  64
.................... 	RetryCount =0; 
*
06A0:  CLRF   46
.................... 	return; 
06A1:  RETURN
.................... } 
....................  
....................  
.................... //				trnsmission of  bit 1			// 
.................... /********************************************************************* 
....................  * Function:       void txmit0(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  bit 1 to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
....................  
.................... void txmit1(void) 
....................  
.................... {      
....................   	txmit_error = 0; 
*
02A7:  BCF    31.6
.................... 	if (input(rx)==1) 
02A8:  BSF    03.5
02A9:  BSF    05.2
02AA:  BCF    03.5
02AB:  BTFSS  05.2
02AC:  GOTO   2B1
.................... 	{   
.................... 		output_bit(tx,0); 
02AD:  BCF    05.0
02AE:  BSF    03.5
02AF:  BCF    05.0
02B0:  BCF    03.5
.................... 	} 
.................... 	delay_us(79); 
02B1:  MOVLW  19
02B2:  MOVWF  20
02B3:  DECFSZ 20,F
02B4:  GOTO   2B3
02B5:  GOTO   2B6
02B6:  NOP
.................... 	if (input(rx)==1) 
02B7:  BSF    03.5
02B8:  BSF    05.2
02B9:  BCF    03.5
02BA:  BTFSS  05.2
02BB:  GOTO   2C2
.................... 	{ 
.................... 		output_bit(tx,1); 
02BC:  BSF    05.0
02BD:  BSF    03.5
02BE:  BCF    05.0
.................... 		txmit_error = 1; 
02BF:  BCF    03.5
02C0:  BSF    31.6
.................... 		return; 
02C1:  GOTO   2F9
.................... 	}			   
.................... 	delay_us(290);//345 
02C2:  MOVLW  60
02C3:  MOVWF  20
02C4:  DECFSZ 20,F
02C5:  GOTO   2C4
02C6:  NOP
.................... 	if (input(rx)==0) 
02C7:  BSF    03.5
02C8:  BSF    05.2
02C9:  BCF    03.5
02CA:  BTFSC  05.2
02CB:  GOTO   2D1
.................... 	{ 
.................... 		output_bit(tx,1); 
02CC:  BSF    05.0
02CD:  BSF    03.5
02CE:  BCF    05.0
.................... 	} 
02CF:  GOTO   2D8
02D0:  BCF    03.5
.................... 	else 
.................... 	{ 
.................... 		output_bit(tx,1); 
02D1:  BSF    05.0
02D2:  BSF    03.5
02D3:  BCF    05.0
.................... 		txmit_error = 1; 
02D4:  BCF    03.5
02D5:  BSF    31.6
.................... 		return; 
02D6:  GOTO   2F9
02D7:  BSF    03.5
.................... 	} 
.................... 	delay_us(79); 
02D8:  MOVLW  19
02D9:  BCF    03.5
02DA:  MOVWF  20
02DB:  DECFSZ 20,F
02DC:  GOTO   2DB
02DD:  GOTO   2DE
02DE:  NOP
.................... 	if (input(rx)==0) 
02DF:  BSF    03.5
02E0:  BSF    05.2
02E1:  BCF    03.5
02E2:  BTFSC  05.2
02E3:  GOTO   2EA
.................... 	{ 
.................... 		output_bit(tx,1); 
02E4:  BSF    05.0
02E5:  BSF    03.5
02E6:  BCF    05.0
.................... 		txmit_error = 1; 
02E7:  BCF    03.5
02E8:  BSF    31.6
.................... 		return; 
02E9:  GOTO   2F9
.................... 	} 
....................     delay_us(290); 
02EA:  MOVLW  60
02EB:  MOVWF  20
02EC:  DECFSZ 20,F
02ED:  GOTO   2EC
02EE:  NOP
.................... 	if (input(rx)==0) 
02EF:  BSF    03.5
02F0:  BSF    05.2
02F1:  BCF    03.5
02F2:  BTFSC  05.2
02F3:  GOTO   2F9
.................... 	{ 
.................... 		output_bit(tx,1); 
02F4:  BSF    05.0
02F5:  BSF    03.5
02F6:  BCF    05.0
.................... 		txmit_error = 1; 
02F7:  BCF    03.5
02F8:  BSF    31.6
.................... 		return; 
.................... 	} 
....................     return; 
02F9:  RETURN
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... //         transmission of 0 to the bus      // 
.................... /********************************************************************* 
....................  * Function:       void txmit0(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  0 bit to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
....................  
.................... void txmit0(void) 
....................  
.................... { 
.................... 	txmit_error = 0;	 
*
0333:  BCF    31.6
.................... 	output_bit(tx,1); 
0334:  BSF    05.0
0335:  BSF    03.5
0336:  BCF    05.0
.................... 	delay_us(79); 
0337:  MOVLW  19
0338:  BCF    03.5
0339:  MOVWF  20
033A:  DECFSZ 20,F
033B:  GOTO   33A
033C:  GOTO   33D
033D:  NOP
.................... 	if (input(rx)!=1) 
033E:  BSF    03.5
033F:  BSF    05.2
0340:  BCF    03.5
0341:  BTFSC  05.2
0342:  GOTO   345
.................... 	{		 
.................... 		txmit_error = 1; 
0343:  BSF    31.6
.................... 		return; 
0344:  GOTO   374
.................... 	}    
.................... 	delay_us(290); 
0345:  MOVLW  60
0346:  MOVWF  20
0347:  DECFSZ 20,F
0348:  GOTO   347
0349:  NOP
.................... 	if (input(rx)==1) 
034A:  BSF    03.5
034B:  BSF    05.2
034C:  BCF    03.5
034D:  BTFSS  05.2
034E:  GOTO   354
.................... 	{ 
.................... 		output_bit(tx,0); 
034F:  BCF    05.0
0350:  BSF    03.5
0351:  BCF    05.0
.................... 	} 
0352:  GOTO   35B
0353:  BCF    03.5
....................     else 
.................... 	{ 
.................... 		output_bit(tx,1); 
0354:  BSF    05.0
0355:  BSF    03.5
0356:  BCF    05.0
.................... 		txmit_error = 1; 
0357:  BCF    03.5
0358:  BSF    31.6
.................... 		return; 
0359:  GOTO   374
035A:  BSF    03.5
.................... 	} 
....................     delay_us(79); 
035B:  MOVLW  19
035C:  BCF    03.5
035D:  MOVWF  20
035E:  DECFSZ 20,F
035F:  GOTO   35E
0360:  GOTO   361
0361:  NOP
....................     if (input(rx)==1) 
0362:  BSF    03.5
0363:  BSF    05.2
0364:  BCF    03.5
0365:  BTFSS  05.2
0366:  GOTO   369
.................... 	{		 
.................... 		txmit_error = 1; 
0367:  BSF    31.6
.................... 		return; 
0368:  GOTO   374
.................... 	} 
....................     delay_us(290); 
0369:  MOVLW  60
036A:  MOVWF  20
036B:  DECFSZ 20,F
036C:  GOTO   36B
036D:  NOP
.................... 	if (input(rx)==1) 
036E:  BSF    03.5
036F:  BSF    05.2
0370:  BCF    03.5
0371:  BTFSS  05.2
0372:  GOTO   374
.................... 	{		 
.................... 		txmit_error = 1; 
0373:  BSF    31.6
.................... 		return; 
.................... 	} 
....................     return; 
.................... } 
.................... //----------------------------------------------------------------------------- 
....................                    // txmit2 bit 
.................... //----------------------------------------------------------------------------- 
....................  
.................... void txmit(char priority,char length) 
.................... {  
.................... 	 
....................      j= 8*length; 
*
0317:  RLF    65,W
0318:  MOVWF  3E
0319:  RLF    3E,F
031A:  RLF    3E,F
031B:  MOVLW  F8
031C:  ANDWF  3E,F
.................... 	 while (settling_time < 12+Fixlampid);     // priority 
031D:  MOVF   3B,W
031E:  SUBLW  14
031F:  BTFSC  03.0
0320:  GOTO   31D
....................      disable_interrupts(global); 
0321:  BCF    0B.6
0322:  BCF    0B.7
0323:  BTFSC  0B.7
0324:  GOTO   322
....................      txmit1();        // start bit   
0325:  CALL   2A7
....................      for(i=0;i<j;i++) 
0326:  CLRF   3C
0327:  MOVF   3E,W
0328:  SUBWF  3C,W
0329:  BTFSC  03.0
032A:  GOTO   378
....................          { 
....................             if (shift_left(tx_buffer,3,1)==1) 
032B:  BSF    03.0
032C:  RLF    3F,F
032D:  RLF    40,F
032E:  RLF    41,F
032F:  BTFSS  03.0
0330:  GOTO   333
....................             { 
....................                  txmit1(); 
0331:  CALL   2A7
....................             } 
0332:  GOTO   374
....................             else 
....................             { 
....................                   txmit0(); 
....................             } 
....................             if (txmit_error ==1) 
*
0374:  BTFSC  31.6
....................             { 
.................... 			//	output_low(pin_c3); 
....................                goto rr; 
0375:  GOTO   37C
....................             }		 
0376:  INCF   3C,F
0377:  GOTO   327
....................          }         
....................      stopbit();     
0378:  CALL   2FA
....................      stopbit();  
0379:  CALL   2FA
.................... 	stopbit(); stopbit(); 
037A:  CALL   2FA
037B:  CALL   2FA
.................... rr:  output_bit(tx,1); 
037C:  BSF    05.0
037D:  BSF    03.5
037E:  BCF    05.0
.................... 	 settling_time = 0; 
037F:  BCF    03.5
0380:  CLRF   3B
....................      intf =0; 
0381:  BCF    0B.1
....................      enable_interrupts(global);	 
0382:  MOVLW  C0
0383:  IORWF  0B,F
.................... 	 enable_interrupts(INT_RTCC); 
0384:  BSF    0B.5
....................      return; 
0385:  RETURN
.................... } 
....................  
.................... //-------------------------------------------------------------------------- 
....................           // stop bit function // 
.................... //-------------------------------------------------------------------------- 
.................... void  stopbit(void) 
.................... { 
....................       output_bit(tx,1); 
*
02FA:  BSF    05.0
02FB:  BSF    03.5
02FC:  BCF    05.0
.................... 	  //restart_wdt();  
....................       delay_us(830); 
02FD:  MOVLW  05
02FE:  BCF    03.5
02FF:  MOVWF  66
0300:  MOVLW  A3
0301:  MOVWF  67
*
0314:  DECFSZ 66,F
0315:  GOTO   300
....................       return; 
0316:  RETURN
.................... } 
....................  
.................... //-------------------------------------------------------------------------- 
....................  
....................  
.................... void readData(void) 
.................... { 
.................... 	//restart_wdt();  
....................       error_flag=0; 
*
00C5:  BCF    31.4
....................       datacount++; 
00C6:  INCF   32,F
....................       forwrdFrameFlag = 0; 
00C7:  BCF    4C.0
.................... 	  backwardFrameFlag =0; 
00C8:  BCF    4C.1
....................       if(datacount< 27) 
00C9:  MOVF   32,W
00CA:  SUBLW  1A
00CB:  BTFSS  03.0
00CC:  GOTO   130
....................       { 
....................          if((a==0 )&& (b==1)) 
00CD:  BTFSC  31.1
00CE:  GOTO   0D6
00CF:  BTFSS  31.3
00D0:  GOTO   0D6
....................          { 
....................             shift_left(data,3,1);  // a one  detewcted on bus  
00D1:  BSF    03.0
00D2:  RLF    33,F
00D3:  RLF    34,F
00D4:  RLF    35,F
....................          } 
00D5:  GOTO   12F
....................          else if((a==1)&&(b==0)) 
00D6:  BTFSS  31.1
00D7:  GOTO   0DF
00D8:  BTFSC  31.3
00D9:  GOTO   0DF
....................          { 
....................             shift_left(data,3,0);  // a zero is  deted on the bus  
00DA:  BCF    03.0
00DB:  RLF    33,F
00DC:  RLF    34,F
00DD:  RLF    35,F
....................          } 
00DE:  GOTO   12F
....................          else if ( a==1 && b==1) 
00DF:  BTFSS  31.1
00E0:  GOTO   126
00E1:  BTFSS  31.3
00E2:  GOTO   126
....................          { 
....................             switch (datacount) 
00E3:  MOVF   32,W
00E4:  XORLW  11
00E5:  BTFSC  03.2
00E6:  GOTO   0F1
00E7:  XORLW  03
00E8:  BTFSC  03.2
00E9:  GOTO   0F3
00EA:  XORLW  0B
00EB:  BTFSC  03.2
00EC:  GOTO   107
00ED:  XORLW  03
00EE:  BTFSC  03.2
00EF:  GOTO   109
00F0:  GOTO   11C
....................             { 
....................                case 17: 
....................                { 
....................                      stopBitCount ++; 
00F1:  INCF   48,F
....................                      break; 
00F2:  GOTO   125
....................                } 
....................                case 18: 
....................                { 
....................                   stopBitCount ++; 
00F3:  INCF   48,F
....................                   if(stopBitCount == 2) 
00F4:  MOVF   48,W
00F5:  SUBLW  02
00F6:  BTFSS  03.2
00F7:  GOTO   0FF
....................                   { 
....................                         r_a=1;  
00F8:  MOVLW  01
00F9:  MOVWF  42
....................                         copyData(); 
00FA:  CALL   05B
....................                         forwrdFrameFlag = 1; 
00FB:  BSF    4C.0
....................                         masterflag = 0; 
00FC:  BCF    4C.2
....................                         backwardFrameFlag =0; 
00FD:  BCF    4C.1
....................  
....................                   } 
00FE:  GOTO   106
....................                   else 
....................                   { 
.................... 						error_flag =1; 
00FF:  BSF    31.4
.................... 						clear_interrupt(int_ext); 
0100:  BCF    0B.1
.................... 						enable_interrupts(INT_EXT); 
0101:  BSF    0B.4
....................     				  disable_interrupts(int_timer1); 
0102:  BSF    03.5
0103:  BCF    0C.0
....................     		          enable_interrupts(INT_RTCC); 
0104:  BCF    03.5
0105:  BSF    0B.5
....................                   } 
....................                   break; 
0106:  GOTO   125
....................                } 
....................               	case 25: 
.................... 				{ 
.................... 					stopBitCount ++; 
0107:  INCF   48,F
.................... 					break; 
0108:  GOTO   125
.................... 				} 
....................               	case 26:  
.................... 				{ 
.................... 					stopBitCount ++; 
0109:  INCF   48,F
.................... 					if(stopBitCount == 2) 
010A:  MOVF   48,W
010B:  SUBLW  02
010C:  BTFSS  03.2
010D:  GOTO   114
.................... 					{ 
.................... 						r_a=0;  
010E:  CLRF   42
.................... 						copyData(); 
010F:  CALL   05B
.................... 						forwrdFrameFlag =0; 
0110:  BCF    4C.0
.................... 						masterflag = 1; 
0111:  BSF    4C.2
.................... 						backwardFrameFlag =0; 
0112:  BCF    4C.1
.................... 					} 
0113:  GOTO   11B
.................... 					else 
.................... 					{ 
.................... 						error_flag =1; 
0114:  BSF    31.4
.................... 						clear_interrupt(int_ext); 
0115:  BCF    0B.1
.................... 						enable_interrupts(INT_EXT); 
0116:  BSF    0B.4
....................     				  disable_interrupts(int_timer1); 
0117:  BSF    03.5
0118:  BCF    0C.0
....................     		          enable_interrupts(INT_RTCC); 
0119:  BCF    03.5
011A:  BSF    0B.5
.................... 					} 
.................... 					break; 
011B:  GOTO   125
.................... 				} 
....................                 default: 
....................                 { 
....................                       error_flag=1; 
011C:  BSF    31.4
....................                       timerOnOff=0; 
011D:  BCF    10.0
.................... 					  clear_interrupt(int_ext); 
011E:  BCF    0B.1
....................                       enable_interrupts(INT_EXT); 
011F:  BSF    0B.4
....................     				  disable_interrupts(int_timer1); 
0120:  BSF    03.5
0121:  BCF    0C.0
....................     		          enable_interrupts(INT_RTCC); 
0122:  BCF    03.5
0123:  BSF    0B.5
....................                       settling_time = 0; 
0124:  CLRF   3B
....................                       break; 
....................                 } 
....................              }    
....................           }  
0125:  GOTO   12F
.................... 		else 
.................... 		{ 
.................... 			error_flag=1;     
0126:  BSF    31.4
.................... 			settling_time = 0; 
0127:  CLRF   3B
.................... 			timerOnOff=0;     
0128:  BCF    10.0
.................... 			clear_interrupt(int_ext);    
0129:  BCF    0B.1
.................... 			enable_interrupts(INT_EXT); 
012A:  BSF    0B.4
....................     		disable_interrupts(int_timer1); 
012B:  BSF    03.5
012C:  BCF    0C.0
....................     		enable_interrupts(INT_RTCC);          
012D:  BCF    03.5
012E:  BSF    0B.5
.................... 		} 
....................       } 
012F:  GOTO   139
.................... 	else  // the  data count grater than 27  
.................... 	{ 
.................... 		over_flowflag =1 ; 
0130:  BSF    31.5
.................... 		settling_time = 0; 
0131:  CLRF   3B
.................... 		timerOnOff=0;    
0132:  BCF    10.0
.................... 		clear_interrupt(int_ext);     
0133:  BCF    0B.1
.................... 		enable_interrupts(INT_EXT); 
0134:  BSF    0B.4
....................         disable_interrupts(int_timer1); 
0135:  BSF    03.5
0136:  BCF    0C.0
....................         enable_interrupts(INT_RTCC);         
0137:  BCF    03.5
0138:  BSF    0B.5
.................... 	} 
....................     return; 
.................... } 
....................  
....................  
....................  
....................  
.................... void copyData(void) 
.................... {  
.................... 	dataReady =1;     
*
005B:  BSF    31.7
.................... 	if( r_a==1) 
005C:  DECFSZ 42,W
005D:  GOTO   063
.................... 	{ 
.................... 		address = data[1]; 
005E:  MOVF   34,W
005F:  MOVWF  49
.................... 		command =data[0];						 
0060:  MOVF   33,W
0061:  MOVWF  4A
.................... 	} 
0062:  GOTO   06C
.................... 	else if( r_a==0) 
0063:  MOVF   42,F
0064:  BTFSS  03.2
0065:  GOTO   06C
.................... 	{	 
.................... 		address = data[2]; 
0066:  MOVF   35,W
0067:  MOVWF  49
.................... 		command =data[1]; 
0068:  MOVF   34,W
0069:  MOVWF  4A
.................... 		databyte=data[0];  
006A:  MOVF   33,W
006B:  MOVWF  4B
.................... 	}        
....................     timerOnOff=0; 
006C:  BCF    10.0
....................     intf =0; 
006D:  BCF    0B.1
.................... 	clear_interrupt(int_ext); 
006E:  BCF    0B.1
....................     enable_interrupts(INT_EXT); 
006F:  BSF    0B.4
....................     disable_interrupts(int_timer1); 
0070:  BSF    03.5
0071:  BCF    0C.0
....................     enable_interrupts(INT_RTCC); 
0072:  BCF    03.5
0073:  BSF    0B.5
....................     settling_time = 0; 
0074:  CLRF   3B
....................     return; 
0075:  RETURN
.................... } 
....................  
....................  
.................... void commands(void) 
.................... {  
.................... 	command_st =0;	 
*
0386:  CLRF   45
.................... 	switch(command) 
0387:  MOVF   4A,W
0388:  XORLW  C9
0389:  BTFSC  03.2
038A:  GOTO   3D4
038B:  XORLW  19
038C:  BTFSC  03.2
038D:  GOTO   3F1
038E:  XORLW  04
038F:  BTFSC  03.2
0390:  GOTO   403
0391:  XORLW  0C
0392:  BTFSC  03.2
0393:  GOTO   40A
0394:  XORLW  29
0395:  BTFSC  03.2
0396:  GOTO   40A
0397:  XORLW  2D
0398:  BTFSC  03.2
0399:  GOTO   415
039A:  XORLW  2C
039B:  BTFSC  03.2
039C:  GOTO   415
039D:  XORLW  1A
039E:  BTFSC  03.2
039F:  GOTO   420
03A0:  XORLW  0D
03A1:  BTFSC  03.2
03A2:  GOTO   445
03A3:  XORLW  EE
03A4:  BTFSC  03.2
03A5:  GOTO   46D
03A6:  XORLW  2B
03A7:  BTFSC  03.2
03A8:  GOTO   530
03A9:  XORLW  01
03AA:  BTFSC  03.2
03AB:  GOTO   554
03AC:  XORLW  07
03AD:  BTFSC  03.2
03AE:  GOTO   559
03AF:  XORLW  01
03B0:  BTFSC  03.2
03B1:  GOTO   580
03B2:  XORLW  03
03B3:  BTFSC  03.2
03B4:  GOTO   589
03B5:  XORLW  01
03B6:  BTFSC  03.2
03B7:  GOTO   598
03B8:  XORLW  16
03B9:  BTFSC  03.2
03BA:  GOTO   5A6
03BB:  XORLW  03
03BC:  BTFSC  03.2
03BD:  GOTO   5CE
03BE:  XORLW  01
03BF:  BTFSC  03.2
03C0:  GOTO   5DD
03C1:  XORLW  19
03C2:  BTFSC  03.2
03C3:  GOTO   5EC
03C4:  XORLW  01
03C5:  BTFSC  03.2
03C6:  GOTO   60C
03C7:  XORLW  1B
03C8:  BTFSC  03.2
03C9:  GOTO   62C
03CA:  XORLW  04
03CB:  BTFSC  03.2
03CC:  GOTO   62E
03CD:  XORLW  01
03CE:  BTFSC  03.2
03CF:  GOTO   63D
03D0:  XORLW  03
03D1:  BTFSC  03.2
03D2:  GOTO   65C
03D3:  GOTO   670
.................... 	{ 
.................... 	   	case 201:	// goto  level  
.................... 		{   
.................... 			 
.................... 			if(databyte>= MaximumLevel ) 
03D4:  MOVF   54,W
03D5:  SUBWF  4B,W
03D6:  BTFSS  03.0
03D7:  GOTO   3DF
.................... 			{ 
.................... 				output_high(pin_c2); 
03D8:  BSF    03.5
03D9:  BCF    07.2
03DA:  BCF    03.5
03DB:  BSF    07.2
.................... 				duty = MaximumLevel;				 
03DC:  MOVF   54,W
03DD:  MOVWF  38
.................... 			} 
03DE:  GOTO   3EF
.................... 			else if(databyte<= MinimumLevel ) 
03DF:  MOVF   4B,W
03E0:  SUBWF  53,W
03E1:  BTFSS  03.0
03E2:  GOTO   3E9
.................... 		    { 
.................... 				output_low(pin_c2); 
03E3:  BSF    03.5
03E4:  BCF    07.2
03E5:  BCF    03.5
03E6:  BCF    07.2
.................... 				duty = 0;								 
03E7:  CLRF   38
.................... 			} 
03E8:  GOTO   3EF
.................... 			else 
.................... 			{ 
.................... 				output_high(pin_c2)	; 
03E9:  BSF    03.5
03EA:  BCF    07.2
03EB:  BCF    03.5
03EC:  BSF    07.2
.................... 				duty =databyte;							 
03ED:  MOVF   4B,W
03EE:  MOVWF  38
.................... 			} 		 
.................... 			lamp_on();										 
03EF:  CALL   277
.................... 			break; 
03F0:  GOTO   672
.................... 		} 
.................... 		case 208:	// on 
.................... 		{   
.................... 			restart_delay=3000; 
03F1:  CLRF   61
03F2:  CLRF   60
03F3:  MOVLW  0B
03F4:  MOVWF  5F
03F5:  MOVLW  B8
03F6:  MOVWF  5E
.................... 			restart_count=0; 
03F7:  CLRF   5D
03F8:  CLRF   5C
03F9:  CLRF   5B
03FA:  CLRF   5A
.................... 			output_high(pin_c2);			 
03FB:  BSF    03.5
03FC:  BCF    07.2
03FD:  BCF    03.5
03FE:  BSF    07.2
.................... 			duty = MaximumLevel; 
03FF:  MOVF   54,W
0400:  MOVWF  38
.................... 			lamp_on();								 
0401:  CALL   277
.................... 			break; 
0402:  GOTO   672
.................... 		} 
.................... 		case 212:	//off 
.................... 		{   
.................... 			output_low(pin_c2); 
0403:  BSF    03.5
0404:  BCF    07.2
0405:  BCF    03.5
0406:  BCF    07.2
.................... 			duty =0; 
0407:  CLRF   38
.................... 			lamp_off(); 
0408:  CALL   273
.................... 			break; 
0409:  GOTO   672
.................... 		} 
.................... 		case 216:	//dim 
.................... 		case 241:		//ZONE DIM 
.................... 		{ 
.................... 			if(l_st==1) 
040A:  DECFSZ 44,W
040B:  GOTO   414
.................... 			{				 
.................... 				if(duty>MinimumLevel) 
040C:  MOVF   38,W
040D:  SUBWF  53,W
040E:  BTFSC  03.0
040F:  GOTO   414
.................... 				{							 
.................... 					duty--; 
0410:  DECF   38,F
.................... 					SetDimmLevel(duty);					 
0411:  MOVF   38,W
0412:  MOVWF  64
0413:  CALL   227
.................... 				} 
.................... 			} 
.................... 			break; 
0414:  GOTO   672
.................... 		} 
.................... 		case 220:	//bright					 
.................... 		case 240:  //zone  bright 
.................... 		{ 
.................... 			if(l_st==1) 
0415:  DECFSZ 44,W
0416:  GOTO   41F
.................... 			{			 
.................... 				if(duty < MaximumLevel) 
0417:  MOVF   54,W
0418:  SUBWF  38,W
0419:  BTFSC  03.0
041A:  GOTO   41F
.................... 				{									 
.................... 					duty++; 
041B:  INCF   38,F
.................... 					SetDimmLevel(duty);			 
041C:  MOVF   38,W
041D:  MOVWF  64
041E:  CALL   227
.................... 				} 
.................... 			} 
.................... 			break; 
041F:  GOTO   672
.................... 		}	 
.................... 	 
.................... 		case 234: // scene select  
.................... 		{				 
.................... 			if(databyte < 17) 
0420:  MOVF   4B,W
0421:  SUBLW  10
0422:  BTFSS  03.0
0423:  GOTO   444
.................... 			{				 
.................... 				currentSceen = databyte;			 
0424:  MOVF   4B,W
0425:  MOVWF  43
.................... 		        duty = read_EEPROM (currentSceen+SceneStore);	 
0426:  MOVLW  06
0427:  ADDWF  43,W
0428:  MOVWF  64
0429:  MOVF   64,W
042A:  BSF    03.5
042B:  MOVWF  1B
042C:  BCF    1C.7
042D:  BSF    1C.0
042E:  MOVF   1A,W
042F:  BCF    03.5
0430:  MOVWF  38
.................... 			     	if(duty<=MinimumLevel) 
0431:  MOVF   38,W
0432:  SUBWF  53,W
0433:  BTFSS  03.0
0434:  GOTO   43C
.................... 					{ 
.................... 						duty=0; 
0435:  CLRF   38
.................... 						output_low(pin_c2);				 
0436:  BSF    03.5
0437:  BCF    07.2
0438:  BCF    03.5
0439:  BCF    07.2
.................... 						lamp_off();		 
043A:  CALL   273
.................... 					} 
043B:  GOTO   444
.................... 					else 
.................... 					{	 
.................... 						output_high(pin_c2);								 
043C:  BSF    03.5
043D:  BCF    07.2
043E:  BCF    03.5
043F:  BSF    07.2
.................... 						lamp_on();	 
0440:  CALL   277
.................... 						SetDimmLevel(duty);		 
0441:  MOVF   38,W
0442:  MOVWF  64
0443:  CALL   227
.................... 					}			 
.................... 			} 
.................... 			break; 
0444:  GOTO   672
.................... 		 } 
.................... 		case 231:  // store sceen  
.................... 		{ 
.................... 			if(databyte < 17) 
0445:  MOVF   4B,W
0446:  SUBLW  10
0447:  BTFSS  03.0
0448:  GOTO   46C
.................... 			{				 
.................... 				disable_interrupts (global); 
0449:  BCF    0B.6
044A:  BCF    0B.7
044B:  BTFSC  0B.7
044C:  GOTO   44A
.................... 				write_eeprom(databyte+SceneStore,duty); 
044D:  MOVLW  06
044E:  ADDWF  4B,W
044F:  MOVWF  64
0450:  MOVF   0B,W
0451:  MOVWF  20
0452:  BCF    0B.7
0453:  MOVF   64,W
0454:  BSF    03.5
0455:  MOVWF  1B
0456:  BCF    03.5
0457:  MOVF   38,W
0458:  BSF    03.5
0459:  MOVWF  1A
045A:  BCF    1C.7
045B:  BSF    1C.2
045C:  MOVLW  55
045D:  MOVWF  1D
045E:  MOVLW  AA
045F:  MOVWF  1D
0460:  BSF    1C.1
0461:  BTFSC  1C.1
0462:  GOTO   461
0463:  BCF    1C.2
0464:  BCF    03.5
0465:  MOVF   20,W
0466:  IORWF  0B,F
.................... 				delay_us(5);			 
0467:  GOTO   468
0468:  GOTO   469
0469:  NOP
.................... 				enable_interrupts(global);	 
046A:  MOVLW  C0
046B:  IORWF  0B,F
.................... 			} 
.................... 			break; 
046C:  GOTO   672
.................... 		} 
.................... 		case 9: 
.................... 		{		 
.................... 				GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
046D:  MOVLW  05
046E:  BSF    03.5
046F:  MOVWF  1B
0470:  BCF    1C.7
0471:  BSF    1C.0
0472:  MOVF   1A,W
0473:  BCF    03.5
0474:  MOVWF  64
0475:  MOVLW  04
0476:  BSF    03.5
0477:  MOVWF  1B
0478:  BCF    1C.7
0479:  BSF    1C.0
047A:  MOVF   1A,W
047B:  BCF    03.5
047C:  MOVWF  65
047D:  MOVF   64,W
047E:  MOVWF  50
047F:  MOVF   65,W
0480:  MOVWF  4F
.................... 				gindex = databyte &0x0f;				 
0481:  MOVF   4B,W
0482:  ANDLW  0F
0483:  MOVWF  51
.................... 				switch (databyte & 0x10) 
0484:  MOVF   4B,W
0485:  ANDLW  10
0486:  BTFSC  03.2
0487:  GOTO   48C
0488:  XORLW  10
0489:  BTFSC  03.2
048A:  GOTO   4E0
048B:  GOTO   52F
.................... 				{ 
.................... 					case 0: 
.................... 						{ 
.................... 							bit_clear(GroupSelectReg,gindex); 
048C:  CLRF   23
048D:  MOVLW  01
048E:  MOVWF  22
048F:  MOVF   51,W
0490:  MOVWF  20
0491:  BTFSC  03.2
0492:  GOTO   498
0493:  BCF    03.0
0494:  RLF    22,F
0495:  RLF    23,F
0496:  DECFSZ 20,F
0497:  GOTO   493
0498:  MOVF   22,W
0499:  XORLW  FF
049A:  MOVWF  20
049B:  MOVLW  FF
049C:  XORWF  23,F
049D:  MOVF   20,W
049E:  ANDWF  4F,F
049F:  MOVF   23,W
04A0:  ANDWF  50,F
.................... 							write_eeprom(Group_07Store  ,make8(GroupSelectReg,0)); 
04A1:  MOVF   4F,W
04A2:  MOVWF  64
04A3:  MOVF   0B,W
04A4:  MOVWF  20
04A5:  BCF    0B.7
04A6:  MOVLW  04
04A7:  BSF    03.5
04A8:  MOVWF  1B
04A9:  BCF    03.5
04AA:  MOVF   4F,W
04AB:  BSF    03.5
04AC:  MOVWF  1A
04AD:  BCF    1C.7
04AE:  BSF    1C.2
04AF:  MOVLW  55
04B0:  MOVWF  1D
04B1:  MOVLW  AA
04B2:  MOVWF  1D
04B3:  BSF    1C.1
04B4:  BTFSC  1C.1
04B5:  GOTO   4B4
04B6:  BCF    1C.2
04B7:  BCF    03.5
04B8:  MOVF   20,W
04B9:  IORWF  0B,F
.................... 							delay_us(10); 
04BA:  MOVLW  02
04BB:  MOVWF  20
04BC:  DECFSZ 20,F
04BD:  GOTO   4BC
04BE:  GOTO   4BF
04BF:  NOP
.................... 							write_eeprom(Group_815Store,make8(GroupSelectReg,1)); 
04C0:  MOVF   50,W
04C1:  MOVWF  64
04C2:  MOVF   0B,W
04C3:  MOVWF  20
04C4:  BCF    0B.7
04C5:  MOVLW  05
04C6:  BSF    03.5
04C7:  MOVWF  1B
04C8:  BCF    03.5
04C9:  MOVF   50,W
04CA:  BSF    03.5
04CB:  MOVWF  1A
04CC:  BCF    1C.7
04CD:  BSF    1C.2
04CE:  MOVLW  55
04CF:  MOVWF  1D
04D0:  MOVLW  AA
04D1:  MOVWF  1D
04D2:  BSF    1C.1
04D3:  BTFSC  1C.1
04D4:  GOTO   4D3
04D5:  BCF    1C.2
04D6:  BCF    03.5
04D7:  MOVF   20,W
04D8:  IORWF  0B,F
....................  							delay_us(10); 
04D9:  MOVLW  02
04DA:  MOVWF  20
04DB:  DECFSZ 20,F
04DC:  GOTO   4DB
04DD:  GOTO   4DE
04DE:  NOP
.................... 							break; 
04DF:  GOTO   52F
.................... 						} 
.................... 					case 16: 
.................... 						{ 
.................... 							bit_set(GroupSelectReg,gindex); 
04E0:  CLRF   23
04E1:  MOVLW  01
04E2:  MOVWF  22
04E3:  MOVF   51,W
04E4:  MOVWF  20
04E5:  BTFSC  03.2
04E6:  GOTO   4EC
04E7:  BCF    03.0
04E8:  RLF    22,F
04E9:  RLF    23,F
04EA:  DECFSZ 20,F
04EB:  GOTO   4E7
04EC:  MOVF   22,W
04ED:  IORWF  4F,F
04EE:  MOVF   23,W
04EF:  IORWF  50,F
.................... 							write_eeprom(Group_07Store  ,make8(GroupSelectReg,0)); 
04F0:  MOVF   4F,W
04F1:  MOVWF  64
04F2:  MOVF   0B,W
04F3:  MOVWF  20
04F4:  BCF    0B.7
04F5:  MOVLW  04
04F6:  BSF    03.5
04F7:  MOVWF  1B
04F8:  BCF    03.5
04F9:  MOVF   4F,W
04FA:  BSF    03.5
04FB:  MOVWF  1A
04FC:  BCF    1C.7
04FD:  BSF    1C.2
04FE:  MOVLW  55
04FF:  MOVWF  1D
0500:  MOVLW  AA
0501:  MOVWF  1D
0502:  BSF    1C.1
0503:  BTFSC  1C.1
0504:  GOTO   503
0505:  BCF    1C.2
0506:  BCF    03.5
0507:  MOVF   20,W
0508:  IORWF  0B,F
.................... 							delay_us(10); 
0509:  MOVLW  02
050A:  MOVWF  20
050B:  DECFSZ 20,F
050C:  GOTO   50B
050D:  GOTO   50E
050E:  NOP
.................... 							write_eeprom(Group_815Store,make8(GroupSelectReg,1)); 
050F:  MOVF   50,W
0510:  MOVWF  64
0511:  MOVF   0B,W
0512:  MOVWF  20
0513:  BCF    0B.7
0514:  MOVLW  05
0515:  BSF    03.5
0516:  MOVWF  1B
0517:  BCF    03.5
0518:  MOVF   50,W
0519:  BSF    03.5
051A:  MOVWF  1A
051B:  BCF    1C.7
051C:  BSF    1C.2
051D:  MOVLW  55
051E:  MOVWF  1D
051F:  MOVLW  AA
0520:  MOVWF  1D
0521:  BSF    1C.1
0522:  BTFSC  1C.1
0523:  GOTO   522
0524:  BCF    1C.2
0525:  BCF    03.5
0526:  MOVF   20,W
0527:  IORWF  0B,F
....................  							delay_us(10); 
0528:  MOVLW  02
0529:  MOVWF  20
052A:  DECFSZ 20,F
052B:  GOTO   52A
052C:  GOTO   52D
052D:  NOP
.................... 							break; 
052E:  GOTO   52F
.................... 						} 
.................... 					 
.................... 					default: break; 
....................  
.................... 				} 
.................... 				break ; 
052F:  GOTO   672
.................... 		} 
.................... 		case 34:    // write idividiual device id alias short address  
.................... 		{ 
.................... 			if(databyte <64) 
0530:  MOVF   4B,W
0531:  SUBLW  3F
0532:  BTFSS  03.0
0533:  GOTO   553
.................... 			{ 
.................... 					lampid = databyte; 
0534:  MOVF   4B,W
0535:  MOVWF  59
.................... 					write_eeprom(ShortAddressStore ,lampid); 
0536:  MOVF   0B,W
0537:  MOVWF  20
0538:  BCF    0B.7
0539:  MOVLW  03
053A:  BSF    03.5
053B:  MOVWF  1B
053C:  BCF    03.5
053D:  MOVF   59,W
053E:  BSF    03.5
053F:  MOVWF  1A
0540:  BCF    1C.7
0541:  BSF    1C.2
0542:  MOVLW  55
0543:  MOVWF  1D
0544:  MOVLW  AA
0545:  MOVWF  1D
0546:  BSF    1C.1
0547:  BTFSC  1C.1
0548:  GOTO   547
0549:  BCF    1C.2
054A:  BCF    03.5
054B:  MOVF   20,W
054C:  IORWF  0B,F
.................... 					delay_us(10); 
054D:  MOVLW  02
054E:  MOVWF  20
054F:  DECFSZ 20,F
0550:  GOTO   54F
0551:  GOTO   552
0552:  NOP
.................... 			} 
.................... 		 
.................... 			break;		 
0553:  GOTO   672
.................... 		} 
.................... 		case 35:    // write  DTR  
.................... 		{ 
.................... 					DTR = databyte;	 
0554:  MOVF   4B,W
0555:  MOVWF  56
.................... 					DTR_Ready =1; 
0556:  MOVLW  01
0557:  MOVWF  58
.................... 					break; 
0558:  GOTO   672
.................... 		} 
.................... 		case 36:    // write  DTR  to  adress  location  in data  byte  
.................... 		{ 
.................... 					 
.................... 				DwriteLocation = databyte;	 
0559:  MOVF   4B,W
055A:  MOVWF  57
.................... 				if(DTR_Ready ==1 && DwriteLocation<33 ) 
055B:  DECFSZ 58,W
055C:  GOTO   57E
055D:  MOVF   57,W
055E:  SUBLW  20
055F:  BTFSS  03.0
0560:  GOTO   57E
.................... 				{ 
.................... 					DTR_Ready =0; 
0561:  CLRF   58
.................... 					write_eeprom(DwriteLocation,DTR); 
0562:  MOVF   0B,W
0563:  MOVWF  20
0564:  BCF    0B.7
0565:  MOVF   57,W
0566:  BSF    03.5
0567:  MOVWF  1B
0568:  BCF    03.5
0569:  MOVF   56,W
056A:  BSF    03.5
056B:  MOVWF  1A
056C:  BCF    1C.7
056D:  BSF    1C.2
056E:  MOVLW  55
056F:  MOVWF  1D
0570:  MOVLW  AA
0571:  MOVWF  1D
0572:  BSF    1C.1
0573:  BTFSC  1C.1
0574:  GOTO   573
0575:  BCF    1C.2
0576:  BCF    03.5
0577:  MOVF   20,W
0578:  IORWF  0B,F
.................... 					DELAY_US(20); 
0579:  MOVLW  06
057A:  MOVWF  20
057B:  DECFSZ 20,F
057C:  GOTO   57B
057D:  NOP
.................... 				} 
.................... 			init_from_eeprom(); 
057E:  CALL   163
.................... 			break; 
057F:  GOTO   672
.................... 		} 
.................... 		case 37:    // Read  DTR  to  adress  location  in data  byte  
.................... 		{ 
.................... 				tx_buffer[2]=lampid;tx_buffer[1]=DTR; txmit(2,2);  /////////priority changed 
0580:  MOVF   59,W
0581:  MOVWF  41
0582:  MOVF   56,W
0583:  MOVWF  40
0584:  MOVLW  02
0585:  MOVWF  64
0586:  MOVWF  65
0587:  CALL   317
.................... 				break;			 
0588:  GOTO   672
.................... 		} 
.................... 		case 38:    // Read  eeprom  and  store  in dtr   to  adress  location  in data  byte  
.................... 		{ 
.................... 				DwriteLocation = databyte;	 
0589:  MOVF   4B,W
058A:  MOVWF  57
.................... 				if( DwriteLocation<33 ) 
058B:  MOVF   57,W
058C:  SUBLW  20
058D:  BTFSS  03.0
058E:  GOTO   597
.................... 				{ 
.................... 					DTR=Read_eeprom(DwriteLocation); 
058F:  MOVF   57,W
0590:  BSF    03.5
0591:  MOVWF  1B
0592:  BCF    1C.7
0593:  BSF    1C.0
0594:  MOVF   1A,W
0595:  BCF    03.5
0596:  MOVWF  56
.................... 				}	 
.................... 				break;				 
0597:  GOTO   672
.................... 		} 
.................... 		case 39:	// Query current device power level 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=Read_eeprom(0);  
0598:  MOVF   59,W
0599:  MOVWF  41
059A:  BSF    03.5
059B:  CLRF   1B
059C:  BCF    1C.7
059D:  BSF    1C.0
059E:  MOVF   1A,W
059F:  BCF    03.5
05A0:  MOVWF  40
.................... 	    	txmit(2,2);		 
05A1:  MOVLW  02
05A2:  MOVWF  64
05A3:  MOVWF  65
05A4:  CALL   317
.................... 			break; 
05A5:  GOTO   672
....................  
.................... 		} 
.................... 		case 49: // case for setting zoneID  
.................... 		{ 
.................... 			if(databyte >=208 && databyte <=223) 
05A6:  MOVF   4B,W
05A7:  SUBLW  CF
05A8:  BTFSC  03.0
05A9:  GOTO   5CD
05AA:  MOVF   4B,W
05AB:  SUBLW  DF
05AC:  BTFSS  03.0
05AD:  GOTO   5CD
.................... 			{ 
.................... 					zoneid = databyte; 
05AE:  MOVF   4B,W
05AF:  MOVWF  47
.................... 					write_eeprom(ZoneIDStore ,zoneid); 
05B0:  MOVF   0B,W
05B1:  MOVWF  20
05B2:  BCF    0B.7
05B3:  MOVLW  20
05B4:  BSF    03.5
05B5:  MOVWF  1B
05B6:  BCF    03.5
05B7:  MOVF   47,W
05B8:  BSF    03.5
05B9:  MOVWF  1A
05BA:  BCF    1C.7
05BB:  BSF    1C.2
05BC:  MOVLW  55
05BD:  MOVWF  1D
05BE:  MOVLW  AA
05BF:  MOVWF  1D
05C0:  BSF    1C.1
05C1:  BTFSC  1C.1
05C2:  GOTO   5C1
05C3:  BCF    1C.2
05C4:  BCF    03.5
05C5:  MOVF   20,W
05C6:  IORWF  0B,F
.................... 					delay_us(10); 
05C7:  MOVLW  02
05C8:  MOVWF  20
05C9:  DECFSZ 20,F
05CA:  GOTO   5C9
05CB:  GOTO   5CC
05CC:  NOP
.................... 			}		 
.................... 			break; 
05CD:  GOTO   672
....................  
.................... 		} 
.................... 		 
.................... 		case 50: 	// case for first group secion query  
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=Read_eeprom(7);  
05CE:  MOVF   59,W
05CF:  MOVWF  41
05D0:  MOVLW  07
05D1:  BSF    03.5
05D2:  MOVWF  1B
05D3:  BCF    1C.7
05D4:  BSF    1C.0
05D5:  MOVF   1A,W
05D6:  BCF    03.5
05D7:  MOVWF  40
.................... 			txmit(2,2);			 
05D8:  MOVLW  02
05D9:  MOVWF  64
05DA:  MOVWF  65
05DB:  CALL   317
.................... 			break; 
05DC:  GOTO   672
....................  
.................... 		} 
.................... 		case 51: 	// case for second group secion query  
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=Read_eeprom(8);  
05DD:  MOVF   59,W
05DE:  MOVWF  41
05DF:  MOVLW  08
05E0:  BSF    03.5
05E1:  MOVWF  1B
05E2:  BCF    1C.7
05E3:  BSF    1C.0
05E4:  MOVF   1A,W
05E5:  BCF    03.5
05E6:  MOVWF  40
.................... 			txmit(2,2);			 
05E7:  MOVLW  02
05E8:  MOVWF  64
05E9:  MOVWF  65
05EA:  CALL   317
.................... 			break; 
05EB:  GOTO   672
....................  
.................... 		} 
.................... 		case 42: 	// setting max level  
.................... 		{ 
.................... 			MaximumLevel=databyte; 
05EC:  MOVF   4B,W
05ED:  MOVWF  54
.................... 			write_eeprom(MaximumLevelStore,MaximumLevel); 
05EE:  MOVF   0B,W
05EF:  MOVWF  20
05F0:  BCF    0B.7
05F1:  MOVLW  02
05F2:  BSF    03.5
05F3:  MOVWF  1B
05F4:  BCF    03.5
05F5:  MOVF   54,W
05F6:  BSF    03.5
05F7:  MOVWF  1A
05F8:  BCF    1C.7
05F9:  BSF    1C.2
05FA:  MOVLW  55
05FB:  MOVWF  1D
05FC:  MOVLW  AA
05FD:  MOVWF  1D
05FE:  BSF    1C.1
05FF:  BTFSC  1C.1
0600:  GOTO   5FF
0601:  BCF    1C.2
0602:  BCF    03.5
0603:  MOVF   20,W
0604:  IORWF  0B,F
.................... 			delay_us(10);			 
0605:  MOVLW  02
0606:  MOVWF  20
0607:  DECFSZ 20,F
0608:  GOTO   607
0609:  GOTO   60A
060A:  NOP
.................... 			break; 
060B:  GOTO   672
....................  
.................... 		} 
.................... 		case 43: 	// setting min level  
.................... 		{ 
.................... 			MinimumLevel=databyte; 
060C:  MOVF   4B,W
060D:  MOVWF  53
.................... 			write_eeprom(MinimumLevelStore,MinimumLevel); 
060E:  MOVF   0B,W
060F:  MOVWF  20
0610:  BCF    0B.7
0611:  MOVLW  01
0612:  BSF    03.5
0613:  MOVWF  1B
0614:  BCF    03.5
0615:  MOVF   53,W
0616:  BSF    03.5
0617:  MOVWF  1A
0618:  BCF    1C.7
0619:  BSF    1C.2
061A:  MOVLW  55
061B:  MOVWF  1D
061C:  MOVLW  AA
061D:  MOVWF  1D
061E:  BSF    1C.1
061F:  BTFSC  1C.1
0620:  GOTO   61F
0621:  BCF    1C.2
0622:  BCF    03.5
0623:  MOVF   20,W
0624:  IORWF  0B,F
.................... 			delay_us(10);		 
0625:  MOVLW  02
0626:  MOVWF  20
0627:  DECFSZ 20,F
0628:  GOTO   627
0629:  GOTO   62A
062A:  NOP
.................... 			break; 
062B:  GOTO   672
.................... 		} 
.................... 		case 48:	// PWM Restart operation			 
.................... 		{ 
.................... 			ECCPASE=0;		 
062C:  BCF    17.7
.................... 			break; 
062D:  GOTO   672
.................... 		} 
.................... 		case 52:	// Read the no. of times system was shutdown permanently 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=Read_eeprom(SystemFailureRateStore);  
062E:  MOVF   59,W
062F:  MOVWF  41
0630:  MOVLW  21
0631:  BSF    03.5
0632:  MOVWF  1B
0633:  BCF    1C.7
0634:  BSF    1C.0
0635:  MOVF   1A,W
0636:  BCF    03.5
0637:  MOVWF  40
.................... 			txmit(2,2); 
0638:  MOVLW  02
0639:  MOVWF  64
063A:  MOVWF  65
063B:  CALL   317
.................... 			break; 
063C:  GOTO   672
.................... 		} 
.................... 		case 53:	// Set current protection threshold value 
.................... 		{ 
.................... 			current_threshold=databyte; 
063D:  MOVF   4B,W
063E:  MOVWF  63
.................... 			write_eeprom(CurrentThresholdStore,current_threshold); 
063F:  MOVF   0B,W
0640:  MOVWF  20
0641:  BCF    0B.7
0642:  MOVLW  22
0643:  BSF    03.5
0644:  MOVWF  1B
0645:  BCF    03.5
0646:  MOVF   63,W
0647:  BSF    03.5
0648:  MOVWF  1A
0649:  BCF    1C.7
064A:  BSF    1C.2
064B:  MOVLW  55
064C:  MOVWF  1D
064D:  MOVLW  AA
064E:  MOVWF  1D
064F:  BSF    1C.1
0650:  BTFSC  1C.1
0651:  GOTO   650
0652:  BCF    1C.2
0653:  BCF    03.5
0654:  MOVF   20,W
0655:  IORWF  0B,F
.................... 			delay_us(10); 
0656:  MOVLW  02
0657:  MOVWF  20
0658:  DECFSZ 20,F
0659:  GOTO   658
065A:  GOTO   65B
065B:  NOP
.................... 		} 
.................... 		case 54:	// Read current protection threshold value 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=Read_eeprom(CurrentThresholdStore);  
065C:  MOVF   59,W
065D:  MOVWF  41
065E:  MOVLW  22
065F:  BSF    03.5
0660:  MOVWF  1B
0661:  BCF    1C.7
0662:  BSF    1C.0
0663:  MOVF   1A,W
0664:  BCF    03.5
0665:  MOVWF  40
.................... 			txmit(2,2); 
0666:  MOVLW  02
0667:  MOVWF  64
0668:  MOVWF  65
0669:  CALL   317
.................... 			delay_us(10); 
066A:  MOVLW  02
066B:  MOVWF  20
066C:  DECFSZ 20,F
066D:  GOTO   66C
066E:  GOTO   66F
066F:  NOP
.................... 		} 
.................... 		default: 
.................... 		{ 
.................... 			command_st=1; 
0670:  MOVLW  01
0671:  MOVWF  45
.................... 			break; 
.................... 		} 
.................... 	} 
.................... 	if(command_st==0) 
0672:  MOVF   45,F
0673:  BTFSS  03.2
0674:  GOTO   68B
.................... 	{ 		 
.................... 		  write_eeprom(PowerOnLevelStore,duty);		 
0675:  MOVF   0B,W
0676:  MOVWF  20
0677:  BCF    0B.7
0678:  BSF    03.5
0679:  CLRF   1B
067A:  BCF    03.5
067B:  MOVF   38,W
067C:  BSF    03.5
067D:  MOVWF  1A
067E:  BCF    1C.7
067F:  BSF    1C.2
0680:  MOVLW  55
0681:  MOVWF  1D
0682:  MOVLW  AA
0683:  MOVWF  1D
0684:  BSF    1C.1
0685:  BTFSC  1C.1
0686:  GOTO   685
0687:  BCF    1C.2
0688:  BCF    03.5
0689:  MOVF   20,W
068A:  IORWF  0B,F
.................... 	} 
.................... 	return; 
.................... } 
....................  
.................... void lamp_on() 
.................... {	 
.................... 	SetDimmLevel(duty); 
*
0277:  MOVF   38,W
0278:  MOVWF  64
0279:  CALL   227
.................... 	l_st=1; 
027A:  MOVLW  01
027B:  MOVWF  44
.................... 	return; 
027C:  RETURN
.................... } 
.................... 	 
.................... void lamp_off() 
.................... {	 
.................... 	SetDimmLevel(0);	 
*
0273:  CLRF   64
0274:  CALL   227
.................... 	l_st=0; 
0275:  CLRF   44
.................... 	return; 
0276:  RETURN
.................... } 
....................  
....................  
.................... 	 
.................... void SetDimmLevel(unsigned int dimPesentage) 
.................... { 
.................... 	if(dimPesentage >= MaximumLevel) 
*
0227:  MOVF   54,W
0228:  SUBWF  64,W
0229:  BTFSS  03.0
022A:  GOTO   22E
.................... 		{ 
.................... 			dimPesentage = MaximumLevel; 
022B:  MOVF   54,W
022C:  MOVWF  64
.................... 		} 
022D:  GOTO   234
.................... 	else if(dimPesentage <= MinimumLevel) 
022E:  MOVF   64,W
022F:  SUBWF  53,W
0230:  BTFSS  03.0
0231:  GOTO   234
.................... 		{ 
.................... 			dimPesentage = MinimumLevel; 
0232:  MOVF   53,W
0233:  MOVWF  64
.................... 		} 
.................... 	 
.................... 	if(dimPesentage <=MinimumLevel) 
0234:  MOVF   64,W
0235:  SUBWF  53,W
0236:  BTFSS  03.0
0237:  GOTO   23D
.................... 		{ 
.................... 			output_low(pin_c2); 
0238:  BSF    03.5
0239:  BCF    07.2
023A:  BCF    03.5
023B:  BCF    07.2
.................... 		} 
023C:  GOTO   241
.................... 	else 
.................... 		{ 
.................... 			output_high(pin_c2); 
023D:  BSF    03.5
023E:  BCF    07.2
023F:  BCF    03.5
0240:  BSF    07.2
.................... 		} 
....................  
.................... 	if(dimPesentage<95) 
0241:  MOVF   64,W
0242:  SUBLW  5E
0243:  BTFSS  03.0
0244:  GOTO   248
.................... 	{ 
.................... 		Power =dimPesentage; 
0245:  CLRF   3A
0246:  MOVF   64,W
0247:  MOVWF  39
.................... 	} 
.................... 	if(dimPesentage>=95) 
0248:  MOVF   64,W
0249:  SUBLW  5E
024A:  BTFSC  03.0
024B:  GOTO   250
.................... 	{ 
.................... 		Power =1023; 
024C:  MOVLW  03
024D:  MOVWF  3A
024E:  MOVLW  FF
024F:  MOVWF  39
.................... 	} 
.................... 	if(Power > 1020){Power =1023;} 
0250:  MOVF   3A,W
0251:  SUBLW  02
0252:  BTFSC  03.0
0253:  GOTO   25F
0254:  XORLW  FF
0255:  BTFSS  03.2
0256:  GOTO   25B
0257:  MOVF   39,W
0258:  SUBLW  FC
0259:  BTFSC  03.0
025A:  GOTO   25F
025B:  MOVLW  03
025C:  MOVWF  3A
025D:  MOVLW  FF
025E:  MOVWF  39
.................... 	set_pwm1_duty(Power); 
025F:  MOVF   3A,W
0260:  MOVWF  22
0261:  MOVF   39,W
0262:  MOVWF  21
0263:  RRF    22,F
0264:  RRF    21,F
0265:  RRF    22,F
0266:  RRF    21,F
0267:  RRF    22,F
0268:  MOVF   21,W
0269:  MOVWF  13
026A:  RRF    22,F
026B:  RRF    22,W
026C:  ANDLW  30
026D:  MOVWF  20
026E:  MOVF   15,W
026F:  ANDLW  CF
0270:  IORWF  20,W
0271:  MOVWF  15
0272:  RETURN
.................... 	} 
....................  
....................  
.................... void init_from_eeprom(void) 
.................... { 
.................... GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
*
0163:  MOVLW  05
0164:  BSF    03.5
0165:  MOVWF  1B
0166:  BCF    1C.7
0167:  BSF    1C.0
0168:  MOVF   1A,W
0169:  BCF    03.5
016A:  MOVWF  64
016B:  MOVLW  04
016C:  BSF    03.5
016D:  MOVWF  1B
016E:  BCF    1C.7
016F:  BSF    1C.0
0170:  MOVF   1A,W
0171:  BCF    03.5
0172:  MOVWF  65
0173:  MOVF   64,W
0174:  MOVWF  50
0175:  MOVF   65,W
0176:  MOVWF  4F
.................... delay_us(10); 
0177:  MOVLW  02
0178:  MOVWF  20
0179:  DECFSZ 20,F
017A:  GOTO   179
017B:  GOTO   17C
017C:  NOP
.................... PowerOnLevel 		= read_EEPROM (PowerOnLevelStore); 
017D:  BSF    03.5
017E:  CLRF   1B
017F:  BCF    1C.7
0180:  BSF    1C.0
0181:  MOVF   1A,W
0182:  BCF    03.5
0183:  MOVWF  55
.................... delay_us(10);     
0184:  MOVLW  02
0185:  MOVWF  20
0186:  DECFSZ 20,F
0187:  GOTO   186
0188:  GOTO   189
0189:  NOP
.................... MinimumLevel		= read_EEPROM ( MinimumLevelStore );    
018A:  MOVLW  01
018B:  BSF    03.5
018C:  MOVWF  1B
018D:  BCF    1C.7
018E:  BSF    1C.0
018F:  MOVF   1A,W
0190:  BCF    03.5
0191:  MOVWF  53
.................... delay_us(10);       	 
0192:  MOVLW  02
0193:  MOVWF  20
0194:  DECFSZ 20,F
0195:  GOTO   194
0196:  GOTO   197
0197:  NOP
.................... MaximumLevel 		= read_EEPROM ( MaximumLevelStore);  
0198:  MOVLW  02
0199:  BSF    03.5
019A:  MOVWF  1B
019B:  BCF    1C.7
019C:  BSF    1C.0
019D:  MOVF   1A,W
019E:  BCF    03.5
019F:  MOVWF  54
.................... delay_us(10);  	 
01A0:  MOVLW  02
01A1:  MOVWF  20
01A2:  DECFSZ 20,F
01A3:  GOTO   1A2
01A4:  GOTO   1A5
01A5:  NOP
.................... lampid 				= read_EEPROM ( ShortAddressStore ); 
01A6:  MOVLW  03
01A7:  BSF    03.5
01A8:  MOVWF  1B
01A9:  BCF    1C.7
01AA:  BSF    1C.0
01AB:  MOVF   1A,W
01AC:  BCF    03.5
01AD:  MOVWF  59
.................... delay_us(10); 
01AE:  MOVLW  02
01AF:  MOVWF  20
01B0:  DECFSZ 20,F
01B1:  GOTO   1B0
01B2:  GOTO   1B3
01B3:  NOP
.................... zoneid=read_EEPROM(zoneidstore); 
01B4:  MOVLW  20
01B5:  BSF    03.5
01B6:  MOVWF  1B
01B7:  BCF    1C.7
01B8:  BSF    1C.0
01B9:  MOVF   1A,W
01BA:  BCF    03.5
01BB:  MOVWF  47
.................... delay_us(10); 
01BC:  MOVLW  02
01BD:  MOVWF  20
01BE:  DECFSZ 20,F
01BF:  GOTO   1BE
01C0:  GOTO   1C1
01C1:  NOP
.................... failure_count=read_EEPROM(SystemFailureRateStore); 
01C2:  MOVLW  21
01C3:  BSF    03.5
01C4:  MOVWF  1B
01C5:  BCF    1C.7
01C6:  BSF    1C.0
01C7:  MOVF   1A,W
01C8:  BCF    03.5
01C9:  MOVWF  62
.................... delay_us(10); 
01CA:  MOVLW  02
01CB:  MOVWF  20
01CC:  DECFSZ 20,F
01CD:  GOTO   1CC
01CE:  GOTO   1CF
01CF:  NOP
.................... current_threshold=read_EEPROM(CurrentThresholdStore); 
01D0:  MOVLW  22
01D1:  BSF    03.5
01D2:  MOVWF  1B
01D3:  BCF    1C.7
01D4:  BSF    1C.0
01D5:  MOVF   1A,W
01D6:  BCF    03.5
01D7:  MOVWF  63
.................... delay_us(10); 
01D8:  MOVLW  02
01D9:  MOVWF  20
01DA:  DECFSZ 20,F
01DB:  GOTO   1DA
01DC:  GOTO   1DD
01DD:  NOP
01DE:  RETURN
.................... } 
....................  
....................  

Configuration Fuses:
   Word  1: 33EC   INTRC_IO WDT PUT MCLR NOPROTECT NOCPD BROWNOUT NOIESO NOFCMEN

ROM data:
002100: 0064 0000 0064 0009 0001 0000 0000 0014 
002108: 001E 0032 0046 005A 0064 0023 0028 002D 
002110: 004B 0019 003C 0041 005F 0064 

002120: 00D4 0000 0001 
