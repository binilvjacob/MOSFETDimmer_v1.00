CCS PCM C Compiler, Version 5.015, 5967               01-May-22 21:54

               Filename:   D:\namami-li\LiHome\MOSFET DRIVER pic code\SLAVE 684 - beta v1.01\slave.lst

               ROM used:   1928 words (94%)
                           Largest free fragment is 120
               RAM used:   71 (55%) at main() level
                           88 (69%) worst case
               Stack used: 5 locations (3 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  06
0001:  MOVWF  0A
0002:  GOTO   65F
0003:  NOP
0004:  BTFSC  03.5
0005:  GOTO   00A
0006:  MOVWF  24
0007:  SWAPF  03,W
0008:  MOVWF  25
0009:  GOTO   00F
000A:  BCF    03.5
000B:  MOVWF  24
000C:  SWAPF  03,W
000D:  MOVWF  25
000E:  BSF    25.1
000F:  MOVF   0A,W
0010:  MOVWF  2B
0011:  CLRF   0A
0012:  BCF    03.7
0013:  SWAPF  24,F
0014:  MOVF   04,W
0015:  MOVWF  26
0016:  MOVF   20,W
0017:  MOVWF  27
0018:  MOVF   21,W
0019:  MOVWF  28
001A:  MOVF   22,W
001B:  MOVWF  29
001C:  MOVF   23,W
001D:  MOVWF  2A
001E:  BCF    03.5
001F:  BTFSS  0B.5
0020:  GOTO   023
0021:  BTFSC  0B.2
0022:  GOTO   13C
0023:  BTFSS  0B.4
0024:  GOTO   027
0025:  BTFSC  0B.1
0026:  GOTO   040
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.0
002A:  GOTO   02D
002B:  BTFSC  0C.0
002C:  GOTO   074
002D:  MOVF   26,W
002E:  MOVWF  04
002F:  MOVF   27,W
0030:  MOVWF  20
0031:  MOVF   28,W
0032:  MOVWF  21
0033:  MOVF   29,W
0034:  MOVWF  22
0035:  MOVF   2A,W
0036:  MOVWF  23
0037:  MOVF   2B,W
0038:  MOVWF  0A
0039:  SWAPF  25,W
003A:  MOVWF  03
003B:  BCF    03.5
003C:  SWAPF  24,W
003D:  BTFSC  25.1
003E:  BSF    03.5
003F:  RETFIE
....................  
.................... 								// MOSFET DIMMABLE DRIVER VERSION 1 BETA v1.00 // 
.................... /*  
.................... 	   Details :  
....................  
.................... 	-> Faderate concept removed to execute over current shutdown 
.................... 	-> PWM auto shutdown enabled 
.................... 	-> PWM auto restart disabled 
.................... 	-> PWM restart delay increments sequentially 
.................... 	-> Hardware relay connected to PIN_C2 
.................... 	-> Comparator 2 with inverted output is used 
.................... 	-> CCP1 module is used in PWM mode 
.................... 	-> Device type ID : 7 
.................... 	-> DALI Tx pin : PIN_A0 
.................... 	-> DALI Rx pin : PIN_A2 
.................... 	-> Version : BETA 
.................... 	-> Last modified date : 30/04/2022     
.................... 	-> Github repo URL :  . 
....................  
.................... */ 
....................   
....................  
.................... #include <slave.h> 
.................... #include <16F684.h> 
.................... //////////// Standard Header file for the PIC16F684 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F684 
*
0270:  MOVLW  20
0271:  MOVWF  71
0272:  CLRF   6D
0273:  CLRF   6E
0274:  CLRF   6F
0275:  CLRF   70
0276:  MOVF   68,W
0277:  MOVWF  23
0278:  MOVF   67,W
0279:  MOVWF  22
027A:  MOVF   66,W
027B:  MOVWF  21
027C:  MOVF   65,W
027D:  MOVWF  20
027E:  BCF    03.0
027F:  BTFSS  20.0
0280:  GOTO   28F
0281:  MOVF   69,W
0282:  ADDWF  6D,F
0283:  MOVF   6A,W
0284:  BTFSC  03.0
0285:  INCFSZ 6A,W
0286:  ADDWF  6E,F
0287:  MOVF   6B,W
0288:  BTFSC  03.0
0289:  INCFSZ 6B,W
028A:  ADDWF  6F,F
028B:  MOVF   6C,W
028C:  BTFSC  03.0
028D:  INCFSZ 6C,W
028E:  ADDWF  70,F
028F:  RRF    70,F
0290:  RRF    6F,F
0291:  RRF    6E,F
0292:  RRF    6D,F
0293:  RRF    23,F
0294:  RRF    22,F
0295:  RRF    21,F
0296:  RRF    20,F
0297:  DECFSZ 71,F
0298:  GOTO   27E
0299:  GOTO   700 (RETURN)
....................  
.................... #list 
....................  
....................  
.................... #device adc=8 
....................  
.................... #FUSES WDT                 		// Watch Dog Timer 
.................... #FUSES INTRC_IO                 //Crystal osc <= 4mhz for PCM/PCH , 3mhz to 10 mhz for PCD 
.................... //#FUSES XT 
.................... #FUSES NOPROTECT             	// Code not protected from reading 
.................... #FUSES BROWNOUT              	// Reset when brownout detected 
.................... #FUSES MCLR                  	// Master Clear pin enabled 
.................... #FUSES NOCPD                 	// No EE protection 
.................... #FUSES PUT                 		// Power Up Timer 
.................... #FUSES NOIESO                	// Internal External Switch Over mode disabled 
.................... #FUSES NOFCMEN               	// Fail-safe clock monitor disabled 
....................  
.................... #use delay(clock=4000000) 
....................  
.................... #include<math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0688:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #use delay(clock=4000000) 
*
02F5:  MOVLW  12
02F6:  SUBWF  68,F
02F7:  BTFSS  03.0
02F8:  GOTO   307
02F9:  MOVLW  68
02FA:  MOVWF  04
02FB:  MOVLW  FC
02FC:  ANDWF  00,F
02FD:  BCF    03.0
02FE:  RRF    00,F
02FF:  RRF    00,F
0300:  MOVF   00,W
0301:  BTFSC  03.2
0302:  GOTO   307
0303:  GOTO   305
0304:  NOP
0305:  DECFSZ 00,F
0306:  GOTO   304
*
064A:  MOVLW  65
064B:  MOVWF  04
064C:  MOVF   00,W
064D:  BTFSC  03.2
064E:  GOTO   65D
064F:  MOVLW  01
0650:  MOVWF  21
0651:  CLRF   20
0652:  DECFSZ 20,F
0653:  GOTO   652
0654:  DECFSZ 21,F
0655:  GOTO   651
0656:  MOVLW  4A
0657:  MOVWF  20
0658:  DECFSZ 20,F
0659:  GOTO   658
065A:  GOTO   65B
065B:  DECFSZ 00,F
065C:  GOTO   64F
....................  
.................... #define device_type 7  				// setting device type 7 - MOSFET dimamble driver 
....................  
.................... #define Fixlampid   1 				// LAMP ADDRESS // 
.................... #define zoneid_init   210 			// zone address //  
.................... #define G1 0b00000001 
.................... #define G2 0b00000000 
.................... #define rx pin_a2 
.................... #define tx pin_a0 
.................... #define self 0x01 
....................  
.................... #define MaxDuty  100  
.................... #define MinDuty  0 
....................  
.................... /////////////////////////////////////////////////////////////// 
....................  
.................... #define PowerOnLevelStore    		0        	// Latest power level    
.................... #define MinimumLevelStore           1			// Minimum allowable power level 
.................... #define MaximumLevelStore  			2 			// Maximum allowable power level 
.................... #define ShortAddressStore  			3  			// Unique device ID 
.................... #define Group_07Store    			4			// First byte of group 
.................... #define Group_815Store  			5			// Second byte of group 
.................... #define SceneStore  				6			// 6-21 Scene level store 
.................... #define ZoneIDStore 				32 
.................... #define SystemFailureRateStore 		25 
.................... #define CurrentThresholdStore 		26			// To store current protection threshold value 
....................  
.................... ////////////////// Device types //////////////////////// 
.................... /* 
.................... 	lamp =1 
.................... 	fan=2 
.................... 	curtain=3 
.................... 	strip=4 
.................... 	mosfet dimamble driver = 7 
.................... */ 
.................... //////////////////////////////////////////////////////// 
....................  
.................... #bit PRSEN     = 0x16.7   // PWM autorestart control bit 
.................... #bit CCMCON0 = 0x019.5	  // Comparator output invert bit 
.................... #bit ECCPASE = 0x017.7	  // PWM shutdown event status bit 
....................  
.................... #byte dutyreg = 0x15 
....................   
.................... #bit intf = 0x0b.1 
.................... #bit timerOnOff =0x10.0 
....................  
.................... int1 oddevenbit,a,atmp,b,error_flag,over_flowflag; 
.................... unsigned int8 dataCount; 
.................... char data[3],bitcount,tout; 
.................... unsigned char duty; 
....................  
.................... unsigned int16 power; 
....................  
.................... char settling_time,i,dly=4,j; 
.................... int1 txmit_error=0; 
.................... char tx_buffer[3]; 
.................... char r_a,currentSceen; 
.................... char l_st; 
.................... char command_st,RetryCount; 
....................  
.................... char zoneid=zoneid_init; 
....................  
.................... char stopBitCount,address ,command,databyte; 
.................... int1 dataready,forwrdFrameFlag,backwardFrameFlag ,masterFlag ; 
.................... int16 readDly=300; 
.................... int16 GroupSelectReg; 
.................... char gindex; 
....................  
.................... /////// new  ////// 
.................... int txmit_count=0; 
.................... int error_value=0; 
.................... /////////////////// 
....................  
.................... char MinimumLevel; 
.................... char MaximumLevel; 
.................... char PowerOnLevel; 
.................... char DTR,DwriteLocation,DTR_Ready; 
....................  
.................... char lampid  = Fixlampid; 
....................  
.................... int1 reset_flag=0;			// For WDT reset operation inside RTCC interrupt 
....................  
.................... int32 restart_count=0; 
.................... int32 restart_delay=0; 
.................... char failure_count=0; 
.................... char current_threshold=1; 
....................  
.................... void readData(void); 
.................... void init(void); 
.................... void handle(void ); 
.................... void copyData(void); 
.................... void commands(void); 
.................... void txmit(char priority,char length); 
.................... void txmit1(void); 
.................... void txmit0(void); 
.................... void stopbit(void); 
.................... void lamp_on(void); 
.................... void lamp_off(void); 
.................... void startBit(void); 
.................... void init_from_eeprom(void); 
.................... void SetDimmLevel(unsigned int dimPesentage); 
....................  
....................  
.................... #rom  0x2100={MaxDuty,MinDuty,MaxDuty,Fixlampid,G1,G2,0,20,30,50,70,90,100,35,40,45,75,25,60,65,95,100} 
....................  
.................... #rom  0x2120={zoneid_init} 
....................  
.................... #int_EXT 
.................... EXT_isr()  
.................... { 
.................... 			clear_interrupt(int_ext); 
*
0040:  BCF    0B.1
....................             disable_interrupts(int_ext); 
0041:  BCF    0B.4
....................             disable_interrupts(INT_RTCC); 
0042:  BCF    0B.5
....................             bitcount=0; 
0043:  CLRF   36
....................             setup_timer_1(T1_internal|T1_div_by_1); 
0044:  MOVLW  05
0045:  MOVWF  10
....................             set_timer1(0xffff-840); //858  880///old value 923 
0046:  CLRF   0E
0047:  MOVLW  FC
0048:  MOVWF  0F
0049:  MOVLW  B7
004A:  MOVWF  0E
....................             enable_interrupts(int_timer1); 
004B:  BSF    03.5
004C:  BSF    0C.0
....................             stopBitCount = 0; 
004D:  BCF    03.5
004E:  CLRF   48
....................             oddevenbit=1; 
004F:  BSF    31.0
....................             data[0]=0; 
0050:  CLRF   33
....................             data[1]=0; 
0051:  CLRF   34
....................             data[2]=0; 
0052:  CLRF   35
....................             tout=0 ; 
0053:  CLRF   37
....................             datacount = 0;    
0054:  CLRF   32
.................... 			settling_time = 0;  
0055:  CLRF   3B
.................... } 
....................  
....................  
0056:  BCF    0B.1
0057:  BCF    0A.3
0058:  GOTO   02D
.................... #int_TIMER1 
.................... TIMER1_isr() 
.................... { 
....................  
.................... readDly=20; 
*
0074:  CLRF   4E
0075:  MOVLW  14
0076:  MOVWF  4D
.................... error_flag=0; 
0077:  BCF    31.4
.................... 	if(oddevenbit==1) 
0078:  BTFSS  31.0
0079:  GOTO   0B5
.................... 	{ 
.................... 		a=input(rx);  
007A:  BSF    03.5
007B:  BSF    05.2
007C:  BCF    03.5
007D:  BCF    31.1
007E:  BTFSC  05.2
007F:  BSF    31.1
.................... 		atmp=a ;           
0080:  BCF    31.2
0081:  BTFSC  31.1
0082:  BSF    31.2
.................... 		oddevenbit=0 ; 
0083:  BCF    31.0
.................... 		 
.................... 				if(atmp) 
0084:  BTFSS  31.2
0085:  GOTO   09C
.................... 				{ 
.................... 					while(atmp) 
0086:  BTFSS  31.2
0087:  GOTO   09B
.................... 						{ 
.................... 							atmp=input(rx); 
0088:  BSF    03.5
0089:  BSF    05.2
008A:  BCF    03.5
008B:  BCF    31.2
008C:  BTFSC  05.2
008D:  BSF    31.2
.................... 							if(readDly>0) 
008E:  MOVF   4D,F
008F:  BTFSS  03.2
0090:  GOTO   094
0091:  MOVF   4E,F
0092:  BTFSC  03.2
0093:  GOTO   099
.................... 								readDly--; 
0094:  MOVF   4D,W
0095:  BTFSC  03.2
0096:  DECF   4E,F
0097:  DECF   4D,F
0098:  GOTO   09A
.................... 							else 
.................... 								atmp=0; 
0099:  BCF    31.2
009A:  GOTO   086
.................... 								 
.................... 						} 
.................... 				}          
009B:  GOTO   0AD
.................... 				else 
.................... 				{ 
.................... 					while(!atmp) 
009C:  BTFSC  31.2
009D:  GOTO   0AD
.................... 						{ 
.................... 							atmp=input(rx); 
009E:  BSF    03.5
009F:  BSF    05.2
00A0:  BCF    03.5
00A1:  BCF    31.2
00A2:  BTFSC  05.2
00A3:  BSF    31.2
.................... 							readDly--; 
00A4:  MOVF   4D,W
00A5:  BTFSC  03.2
00A6:  DECF   4E,F
00A7:  DECFSZ 4D,F
.................... 								if(readdly==0) 
00A8:  GOTO   0AC
00A9:  MOVF   4E,F
00AA:  BTFSC  03.2
.................... 									{ 
.................... 									atmp=1; 
00AB:  BSF    31.2
.................... 									}	 
00AC:  GOTO   09C
.................... 						} 
.................... 				} 
....................  
.................... 			setup_timer_1(T1_internal|T1_div_by_1);//settimer1with1us least count 
00AD:  MOVLW  05
00AE:  MOVWF  10
.................... 			set_timer1(0xffff-150);  //374  //  355             350////old value 150 
00AF:  CLRF   0E
00B0:  MOVLW  FF
00B1:  MOVWF  0F
00B2:  MOVLW  69
00B3:  MOVWF  0E
.................... 	} 
00B4:  GOTO   137
.................... 	else 
.................... 	{  
.................... 		b=input(rx) ; // store data line status in the second half 
00B5:  BSF    03.5
00B6:  BSF    05.2
00B7:  BCF    03.5
00B8:  BCF    31.3
00B9:  BTFSC  05.2
00BA:  BSF    31.3
.................... 		oddevenbit=1; 
00BB:  BSF    31.0
.................... 		setup_timer_1(T1_internal|T1_div_by_1); 
00BC:  MOVLW  05
00BD:  MOVWF  10
.................... 		set_timer1(0xffff-350);  // delay  till the next call st to 73 us/////old value 350 
00BE:  CLRF   0E
00BF:  MOVLW  FE
00C0:  MOVWF  0F
00C1:  MOVLW  A1
00C2:  MOVWF  0E
.................... 		readData();  // function  get the dat from the conditions of a and b 
.................... 					 
.................... 	} 
.................... return(0); 
*
0137:  MOVLW  00
0138:  MOVWF  21
.................... } 
....................  
0139:  BCF    0C.0
013A:  BCF    0A.3
013B:  GOTO   02D
.................... #int_RTCC 
.................... RTCC_isr() 
.................... {	 
.................... 	 
.................... 	reset_flag=1; 
013C:  BSF    4C.3
.................... /* 
.................... 	if(FadeRateCount>0) 
.................... 	{ 
.................... 		FadeRateCount--; 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		FadeRateCount=FadeRate; 
.................... 	} 
.................... */ 
.................... 	dly--; 
013D:  DECFSZ 3D,F
....................   	if (dly == 0) 
013E:  GOTO   145
....................   	{	 
....................       dly = 4; 
013F:  MOVLW  04
0140:  MOVWF  3D
....................       if(settling_time < 250) 
0141:  MOVF   3B,W
0142:  SUBLW  F9
0143:  BTFSC  03.0
....................       { 
....................           settling_time++; 
0144:  INCF   3B,F
....................       }               
....................    } 
.................... 	if(ECCPASE==1 && restart_delay>2) // event just occurred and is not ready for reset 
0145:  BTFSS  17.7
0146:  GOTO   15C
0147:  MOVF   62,F
0148:  BTFSS  03.2
0149:  GOTO   154
014A:  MOVF   61,F
014B:  BTFSS  03.2
014C:  GOTO   154
014D:  MOVF   60,F
014E:  BTFSS  03.2
014F:  GOTO   154
0150:  MOVF   5F,W
0151:  SUBLW  02
0152:  BTFSC  03.0
0153:  GOTO   15C
.................... 		{ 
.................... 			restart_delay--; 
0154:  MOVLW  FF
0155:  ADDWF  5F,F
0156:  BTFSS  03.0
0157:  ADDWF  60,F
0158:  BTFSS  03.0
0159:  ADDWF  61,F
015A:  BTFSS  03.0
015B:  ADDWF  62,F
.................... 		} 
015C:  BCF    0B.2
015D:  BCF    0A.3
015E:  GOTO   02D
.................... } 
....................  
....................  
.................... void main(void) 
*
065F:  MOVF   03,W
0660:  ANDLW  1F
0661:  MOVWF  03
0662:  MOVLW  61
0663:  BSF    03.5
0664:  MOVWF  0F
0665:  MOVF   0F,W
0666:  MOVLW  04
0667:  BCF    03.5
0668:  MOVWF  3D
0669:  BCF    31.6
066A:  MOVLW  D2
066B:  MOVWF  47
066C:  MOVLW  01
066D:  MOVWF  4E
066E:  MOVLW  2C
066F:  MOVWF  4D
0670:  CLRF   52
0671:  CLRF   53
0672:  MOVLW  01
0673:  MOVWF  5A
0674:  BCF    4C.3
0675:  CLRF   5E
0676:  CLRF   5D
0677:  CLRF   5C
0678:  CLRF   5B
0679:  CLRF   62
067A:  CLRF   61
067B:  CLRF   60
067C:  CLRF   5F
067D:  CLRF   63
067E:  MOVLW  01
067F:  MOVWF  64
0680:  BCF    1F.6
0681:  MOVLW  00
0682:  BSF    03.5
0683:  MOVWF  11
0684:  BCF    03.5
0685:  CLRF   1A
0686:  MOVLW  07
0687:  MOVWF  19
....................  
.................... { 
.................... 	setup_wdt(WDT_ON); 
*
0689:  BSF    18.0
.................... 	setup_wdt(WDT_72MS|WDT_TIMES_16);		//~1.1 s reset	 
068A:  MOVLW  11
068B:  MOVWF  18
068C:  MOVLW  0A
068D:  MOVWF  20
068E:  CLRF   01
068F:  MOVLW  81
0690:  MOVWF  04
0691:  MOVF   00,W
0692:  ANDLW  F0
0693:  IORLW  07
0694:  MOVWF  00
0695:  CLRWDT
0696:  MOVF   00,W
0697:  ANDLW  F7
0698:  BTFSC  20.3
0699:  ANDLW  F0
069A:  IORWF  20,W
069B:  MOVWF  00
.................... 	init_from_eeprom(); 
069C:  CALL   15F
.................... 	init();		 
069D:  GOTO   1DB
.................... 	GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
069E:  MOVLW  05
069F:  BSF    03.5
06A0:  MOVWF  1B
06A1:  BCF    1C.7
06A2:  BSF    1C.0
06A3:  MOVF   1A,W
06A4:  BCF    03.5
06A5:  MOVWF  65
06A6:  MOVLW  04
06A7:  BSF    03.5
06A8:  MOVWF  1B
06A9:  BCF    1C.7
06AA:  BSF    1C.0
06AB:  MOVF   1A,W
06AC:  BCF    03.5
06AD:  MOVWF  66
06AE:  MOVF   65,W
06AF:  MOVWF  50
06B0:  MOVF   66,W
06B1:  MOVWF  4F
.................... 	PowerOnLevel = read_EEPROM (PowerOnLevelStore); 
06B2:  BSF    03.5
06B3:  CLRF   1B
06B4:  BCF    1C.7
06B5:  BSF    1C.0
06B6:  MOVF   1A,W
06B7:  BCF    03.5
06B8:  MOVWF  56
.................... 	if(PowerOnLevel<= MinimumLevel) 
06B9:  MOVF   56,W
06BA:  SUBWF  54,W
06BB:  BTFSS  03.0
06BC:  GOTO   6C4
.................... 	{ 
.................... 		output_low(pin_c2); 
06BD:  BSF    03.5
06BE:  BCF    07.2
06BF:  BCF    03.5
06C0:  BCF    07.2
.................... 		duty=0; 
06C1:  CLRF   38
.................... 		lamp_off();				 
06C2:  CALL   266
.................... 	} 
06C3:  GOTO   6CE
.................... 	else 
.................... 	{ 
.................... 		output_high(pin_c2); 
06C4:  BSF    03.5
06C5:  BCF    07.2
06C6:  BCF    03.5
06C7:  BSF    07.2
.................... 		duty = PowerOnLevel; 
06C8:  MOVF   56,W
06C9:  MOVWF  38
.................... 		SetDimmLevel(duty);		 
06CA:  MOVF   38,W
06CB:  MOVWF  65
06CC:  CALL   21A
.................... 		lamp_on();		 
06CD:  CALL   26A
.................... 	} 
.................... 	restart_delay=3000;				// initial restart delay 
06CE:  CLRF   62
06CF:  CLRF   61
06D0:  MOVLW  0B
06D1:  MOVWF  60
06D2:  MOVLW  B8
06D3:  MOVWF  5F
.................... 	restart_count=0;				// initial restart counts 
06D4:  CLRF   5E
06D5:  CLRF   5D
06D6:  CLRF   5C
06D7:  CLRF   5B
.................... 	ECCPASE=0;						// Restart operation 
06D8:  BCF    17.7
....................  
.................... start: 
....................  
.................... 	if(restart_delay<=2 && ECCPASE==1)			// restart after variable delay 
06D9:  MOVF   62,F
06DA:  BTFSS  03.2
06DB:  GOTO   747
06DC:  MOVF   61,F
06DD:  BTFSS  03.2
06DE:  GOTO   747
06DF:  MOVF   60,F
06E0:  BTFSS  03.2
06E1:  GOTO   747
06E2:  MOVF   5F,W
06E3:  SUBLW  02
06E4:  BTFSS  03.0
06E5:  GOTO   747
06E6:  BTFSS  17.7
06E7:  GOTO   747
.................... 	{ 
.................... 		ECCPASE=0;								// PWM restart operation 
06E8:  BCF    17.7
.................... 		restart_count++;						// Increment restart event counter 
06E9:  MOVLW  01
06EA:  ADDWF  5B,F
06EB:  BTFSC  03.0
06EC:  INCF   5C,F
06ED:  BTFSC  03.2
06EE:  INCF   5D,F
06EF:  BTFSC  03.2
06F0:  INCF   5E,F
.................... 		restart_delay=restart_delay+restart_count*5000;		// Increasing the restart delay 
06F1:  MOVF   5E,W
06F2:  MOVWF  68
06F3:  MOVF   5D,W
06F4:  MOVWF  67
06F5:  MOVF   5C,W
06F6:  MOVWF  66
06F7:  MOVF   5B,W
06F8:  MOVWF  65
06F9:  CLRF   6C
06FA:  CLRF   6B
06FB:  MOVLW  13
06FC:  MOVWF  6A
06FD:  MOVLW  88
06FE:  MOVWF  69
06FF:  GOTO   270
0700:  MOVF   20,W
0701:  ADDWF  5F,F
0702:  MOVF   21,W
0703:  BTFSC  03.0
0704:  INCFSZ 21,W
0705:  ADDWF  60,F
0706:  MOVF   22,W
0707:  BTFSC  03.0
0708:  INCFSZ 22,W
0709:  ADDWF  61,F
070A:  MOVF   23,W
070B:  BTFSC  03.0
070C:  INCFSZ 23,W
070D:  ADDWF  62,F
.................... 		if(restart_delay>30000)					// Permanent shutdown after many restart attempts 
070E:  MOVF   62,F
070F:  BTFSS  03.2
0710:  GOTO   71F
0711:  MOVF   61,F
0712:  BTFSS  03.2
0713:  GOTO   71F
0714:  MOVF   60,W
0715:  SUBLW  74
0716:  BTFSC  03.0
0717:  GOTO   747
0718:  XORLW  FF
0719:  BTFSS  03.2
071A:  GOTO   71F
071B:  MOVF   5F,W
071C:  SUBLW  30
071D:  BTFSC  03.0
071E:  GOTO   747
.................... 		{ 
.................... 			output_low(pin_c2); 
071F:  BSF    03.5
0720:  BCF    07.2
0721:  BCF    03.5
0722:  BCF    07.2
.................... 			failure_count++;					// Failed to turn ON 
0723:  INCF   63,F
.................... 			if(failure_count>254) 
0724:  MOVF   63,W
0725:  SUBLW  FE
0726:  BTFSC  03.0
0727:  GOTO   72A
.................... 			{ 
.................... 				failure_count=254; 
0728:  MOVLW  FE
0729:  MOVWF  63
.................... 			} 
.................... 			write_eeprom(SystemFailureRateStore,failure_count); 
072A:  MOVF   0B,W
072B:  MOVWF  20
072C:  BCF    0B.7
072D:  MOVLW  19
072E:  BSF    03.5
072F:  MOVWF  1B
0730:  BCF    03.5
0731:  MOVF   63,W
0732:  BSF    03.5
0733:  MOVWF  1A
0734:  BCF    1C.7
0735:  BSF    1C.2
0736:  MOVLW  55
0737:  MOVWF  1D
0738:  MOVLW  AA
0739:  MOVWF  1D
073A:  BSF    1C.1
073B:  BTFSC  1C.1
073C:  GOTO   73B
073D:  BCF    1C.2
073E:  BCF    03.5
073F:  MOVF   20,W
0740:  IORWF  0B,F
.................... 			delay_us(10);			 
0741:  MOVLW  02
0742:  MOVWF  20
0743:  DECFSZ 20,F
0744:  GOTO   743
0745:  GOTO   746
0746:  NOP
.................... 		}		 
.................... 	} 
.................... 	 
.................... 	if(reset_flag==1) 
0747:  BTFSS  4C.3
0748:  GOTO   74B
.................... 	{ 
.................... 	restart_wdt();  
0749:  CLRWDT
.................... 	reset_flag=0; 
074A:  BCF    4C.3
.................... 	} 
.................... 		 
.................... 	if (dataReady ==1) 
074B:  BTFSS  31.7
074C:  GOTO   779
.................... 	{ 
.................... 		if(address == 0xff) 
074D:  INCFSZ 49,W
074E:  GOTO   751
.................... 		{ 
.................... 			handle();  
074F:  CALL   379
.................... 		}		 
0750:  GOTO   778
.................... 		else if(address==lampid)		{ 
0751:  MOVF   5A,W
0752:  SUBWF  49,W
0753:  BTFSS  03.2
0754:  GOTO   757
.................... 			 
.................... 			handle();  
0755:  CALL   379
.................... 		}		 
0756:  GOTO   778
....................     	else if(address == zoneid) 
0757:  MOVF   47,W
0758:  SUBWF  49,W
0759:  BTFSS  03.2
075A:  GOTO   75D
.................... 		{ 
.................... 			handle();	 
075B:  CALL   379
.................... 		} 
075C:  GOTO   778
.................... 		else if(address>191 && address<208) 
075D:  MOVF   49,W
075E:  SUBLW  BF
075F:  BTFSC  03.0
0760:  GOTO   778
0761:  MOVF   49,W
0762:  SUBLW  CF
0763:  BTFSS  03.0
0764:  GOTO   778
.................... 		{	 
.................... 			gindex = address &0x0F; 
0765:  MOVF   49,W
0766:  ANDLW  0F
0767:  MOVWF  51
.................... 			if ( bit_test (GroupSelectReg, gindex)==1) 
0768:  MOVF   50,W
0769:  MOVWF  23
076A:  MOVF   4F,W
076B:  MOVWF  22
076C:  MOVF   51,W
076D:  MOVWF  20
076E:  BTFSC  03.2
076F:  GOTO   775
0770:  BCF    03.0
0771:  RRF    23,F
0772:  RRF    22,F
0773:  DECFSZ 20,F
0774:  GOTO   770
0775:  MOVF   22,W
0776:  BTFSC  22.0
.................... 			{ 				 
.................... 				handle(); 
0777:  CALL   379
.................... 			}	 
.................... 		} 
.................... 		dataReady =0; 
0778:  BCF    31.7
.................... 	} 
.................... 	if(txmit_error==1 && txmit_count<5) 
0779:  BTFSS  31.6
077A:  GOTO   785
077B:  MOVF   52,W
077C:  SUBLW  04
077D:  BTFSS  03.0
077E:  GOTO   785
.................... 	{ 
.................... 		txmit_count++; 
077F:  INCF   52,F
.................... 		txmit(2,2); 
0780:  MOVLW  02
0781:  MOVWF  65
0782:  MOVWF  66
0783:  CALL   30A
.................... 	}	 
0784:  GOTO   786
.................... 	else 
.................... 	{ 
.................... 		txmit_count=0; 
0785:  CLRF   52
.................... 	} 
.................... 	 
.................... 	goto start; 
0786:  GOTO   6D9
.................... } 
....................  
0787:  SLEEP
.................... void init(void) 
....................  
.................... { 
.................... 	setup_timer_2(T2_DIV_BY_1,249,1);		//250 us overflow, 250 us interrupt  // 4000Hz 
*
01DB:  MOVLW  00
01DC:  MOVWF  21
01DD:  IORLW  04
01DE:  MOVWF  12
01DF:  MOVLW  F9
01E0:  BSF    03.5
01E1:  MOVWF  12
.................... 	setup_ccp1(CCP_PWM|CCP_SHUTDOWN_ON_COMP2|CCP_SHUTDOWN_AC_L|CCP_SHUTDOWN_BD_L);	// Setting up PWM 
01E2:  BCF    07.5
01E3:  BCF    03.5
01E4:  BCF    07.5
01E5:  MOVLW  0C
01E6:  MOVWF  15
01E7:  CLRF   16
01E8:  MOVLW  20
01E9:  MOVWF  17
.................... 	setup_comparator(A0_VR_C0_VR);				// Setting up comparator 
01EA:  CLRF   1A
01EB:  MOVLW  0A
01EC:  MOVWF  19
01ED:  BSF    03.5
01EE:  MOVF   05,W
01EF:  IORLW  10
01F0:  MOVWF  05
01F1:  MOVLW  02
01F2:  BCF    03.5
01F3:  MOVWF  20
01F4:  DECFSZ 20,F
01F5:  GOTO   1F4
01F6:  GOTO   1F7
01F7:  NOP
01F8:  MOVF   19,W
01F9:  BCF    0C.3
.................... 	setup_vref(VREF_LOW|current_threshold);						// Setting up reference voltage 
01FA:  MOVF   64,W
01FB:  IORLW  A0
01FC:  MOVWF  65
01FD:  BSF    03.5
01FE:  MOVWF  19
.................... 	PRSEN=0;									// Auto-restart disabled 
01FF:  BCF    03.5
0200:  BCF    16.7
.................... 	CCMCON0=1;									// Comparator output inverted 
0201:  BSF    19.5
....................  
.................... 	setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
0202:  BSF    03.5
0203:  MOVF   01,W
0204:  ANDLW  C7
0205:  IORLW  08
0206:  MOVWF  01
.................... 	setup_timer_1(T1_internal|T1_div_by_1); 
0207:  MOVLW  05
0208:  BCF    03.5
0209:  MOVWF  10
.................... 	timerOnOff=0; 
020A:  BCF    10.0
.................... 	clear_interrupt(int_ext); 
020B:  BCF    0B.1
.................... 	ext_int_edge( H_TO_L );	 
020C:  BSF    03.5
020D:  BCF    01.6
.................... 	enable_interrupts(INT_EXT); 
020E:  BCF    03.5
020F:  BSF    0B.4
.................... 	enable_interrupts(INT_RTCC); 
0210:  BSF    0B.5
.................... 	disable_interrupts(INT_TIMER2); 
0211:  BSF    03.5
0212:  BCF    0C.1
.................... 	enable_interrupts(global);	 
0213:  MOVLW  C0
0214:  BCF    03.5
0215:  IORWF  0B,F
.................... 	settling_time =23; 
0216:  MOVLW  17
0217:  MOVWF  3B
.................... 	dataReady =0;   
0218:  BCF    31.7
.................... 	return; 
0219:  GOTO   69E (RETURN)
.................... } 
....................  
.................... void handle(void ) 
.................... { 
.................... 	commands(); 
.................... 	delay_ms(2); 
*
0648:  MOVLW  02
0649:  MOVWF  65
.................... 	RetryCount =0; 
*
065D:  CLRF   46
.................... 	return; 
065E:  RETURN
.................... } 
....................  
....................  
.................... //				trnsmission of  bit 1			// 
.................... /********************************************************************* 
....................  * Function:       void txmit0(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  bit 1 to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
....................  
.................... void txmit1(void) 
....................  
.................... {      
....................   	txmit_error = 0; 
*
029A:  BCF    31.6
.................... 	if (input(rx)==1) 
029B:  BSF    03.5
029C:  BSF    05.2
029D:  BCF    03.5
029E:  BTFSS  05.2
029F:  GOTO   2A4
.................... 	{   
.................... 		output_bit(tx,0); 
02A0:  BCF    05.0
02A1:  BSF    03.5
02A2:  BCF    05.0
02A3:  BCF    03.5
.................... 	} 
.................... 	delay_us(79); 
02A4:  MOVLW  19
02A5:  MOVWF  20
02A6:  DECFSZ 20,F
02A7:  GOTO   2A6
02A8:  GOTO   2A9
02A9:  NOP
.................... 	if (input(rx)==1) 
02AA:  BSF    03.5
02AB:  BSF    05.2
02AC:  BCF    03.5
02AD:  BTFSS  05.2
02AE:  GOTO   2B5
.................... 	{ 
.................... 		output_bit(tx,1); 
02AF:  BSF    05.0
02B0:  BSF    03.5
02B1:  BCF    05.0
.................... 		txmit_error = 1; 
02B2:  BCF    03.5
02B3:  BSF    31.6
.................... 		return; 
02B4:  GOTO   2EC
.................... 	}			   
.................... 	delay_us(290);//345 
02B5:  MOVLW  60
02B6:  MOVWF  20
02B7:  DECFSZ 20,F
02B8:  GOTO   2B7
02B9:  NOP
.................... 	if (input(rx)==0) 
02BA:  BSF    03.5
02BB:  BSF    05.2
02BC:  BCF    03.5
02BD:  BTFSC  05.2
02BE:  GOTO   2C4
.................... 	{ 
.................... 		output_bit(tx,1); 
02BF:  BSF    05.0
02C0:  BSF    03.5
02C1:  BCF    05.0
.................... 	} 
02C2:  GOTO   2CB
02C3:  BCF    03.5
.................... 	else 
.................... 	{ 
.................... 		output_bit(tx,1); 
02C4:  BSF    05.0
02C5:  BSF    03.5
02C6:  BCF    05.0
.................... 		txmit_error = 1; 
02C7:  BCF    03.5
02C8:  BSF    31.6
.................... 		return; 
02C9:  GOTO   2EC
02CA:  BSF    03.5
.................... 	} 
.................... 	delay_us(79); 
02CB:  MOVLW  19
02CC:  BCF    03.5
02CD:  MOVWF  20
02CE:  DECFSZ 20,F
02CF:  GOTO   2CE
02D0:  GOTO   2D1
02D1:  NOP
.................... 	if (input(rx)==0) 
02D2:  BSF    03.5
02D3:  BSF    05.2
02D4:  BCF    03.5
02D5:  BTFSC  05.2
02D6:  GOTO   2DD
.................... 	{ 
.................... 		output_bit(tx,1); 
02D7:  BSF    05.0
02D8:  BSF    03.5
02D9:  BCF    05.0
.................... 		txmit_error = 1; 
02DA:  BCF    03.5
02DB:  BSF    31.6
.................... 		return; 
02DC:  GOTO   2EC
.................... 	} 
....................     delay_us(290); 
02DD:  MOVLW  60
02DE:  MOVWF  20
02DF:  DECFSZ 20,F
02E0:  GOTO   2DF
02E1:  NOP
.................... 	if (input(rx)==0) 
02E2:  BSF    03.5
02E3:  BSF    05.2
02E4:  BCF    03.5
02E5:  BTFSC  05.2
02E6:  GOTO   2EC
.................... 	{ 
.................... 		output_bit(tx,1); 
02E7:  BSF    05.0
02E8:  BSF    03.5
02E9:  BCF    05.0
.................... 		txmit_error = 1; 
02EA:  BCF    03.5
02EB:  BSF    31.6
.................... 		return; 
.................... 	} 
....................     return; 
02EC:  RETURN
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... //         transmission of 0 to the bus      // 
.................... /********************************************************************* 
....................  * Function:       void txmit0(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  0 bit to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
....................  
.................... void txmit0(void) 
....................  
.................... { 
.................... 	txmit_error = 0;	 
*
0326:  BCF    31.6
.................... 	output_bit(tx,1); 
0327:  BSF    05.0
0328:  BSF    03.5
0329:  BCF    05.0
.................... 	delay_us(79); 
032A:  MOVLW  19
032B:  BCF    03.5
032C:  MOVWF  20
032D:  DECFSZ 20,F
032E:  GOTO   32D
032F:  GOTO   330
0330:  NOP
.................... 	if (input(rx)!=1) 
0331:  BSF    03.5
0332:  BSF    05.2
0333:  BCF    03.5
0334:  BTFSC  05.2
0335:  GOTO   338
.................... 	{		 
.................... 		txmit_error = 1; 
0336:  BSF    31.6
.................... 		return; 
0337:  GOTO   367
.................... 	}    
.................... 	delay_us(290); 
0338:  MOVLW  60
0339:  MOVWF  20
033A:  DECFSZ 20,F
033B:  GOTO   33A
033C:  NOP
.................... 	if (input(rx)==1) 
033D:  BSF    03.5
033E:  BSF    05.2
033F:  BCF    03.5
0340:  BTFSS  05.2
0341:  GOTO   347
.................... 	{ 
.................... 		output_bit(tx,0); 
0342:  BCF    05.0
0343:  BSF    03.5
0344:  BCF    05.0
.................... 	} 
0345:  GOTO   34E
0346:  BCF    03.5
....................     else 
.................... 	{ 
.................... 		output_bit(tx,1); 
0347:  BSF    05.0
0348:  BSF    03.5
0349:  BCF    05.0
.................... 		txmit_error = 1; 
034A:  BCF    03.5
034B:  BSF    31.6
.................... 		return; 
034C:  GOTO   367
034D:  BSF    03.5
.................... 	} 
....................     delay_us(79); 
034E:  MOVLW  19
034F:  BCF    03.5
0350:  MOVWF  20
0351:  DECFSZ 20,F
0352:  GOTO   351
0353:  GOTO   354
0354:  NOP
....................     if (input(rx)==1) 
0355:  BSF    03.5
0356:  BSF    05.2
0357:  BCF    03.5
0358:  BTFSS  05.2
0359:  GOTO   35C
.................... 	{		 
.................... 		txmit_error = 1; 
035A:  BSF    31.6
.................... 		return; 
035B:  GOTO   367
.................... 	} 
....................     delay_us(290); 
035C:  MOVLW  60
035D:  MOVWF  20
035E:  DECFSZ 20,F
035F:  GOTO   35E
0360:  NOP
.................... 	if (input(rx)==1) 
0361:  BSF    03.5
0362:  BSF    05.2
0363:  BCF    03.5
0364:  BTFSS  05.2
0365:  GOTO   367
.................... 	{		 
.................... 		txmit_error = 1; 
0366:  BSF    31.6
.................... 		return; 
.................... 	} 
....................     return; 
.................... } 
.................... //----------------------------------------------------------------------------- 
....................                    // txmit2 bit 
.................... //----------------------------------------------------------------------------- 
....................  
.................... void txmit(char priority,char length) 
.................... {  
.................... 	 
....................      j= 8*length; 
*
030A:  RLF    66,W
030B:  MOVWF  3E
030C:  RLF    3E,F
030D:  RLF    3E,F
030E:  MOVLW  F8
030F:  ANDWF  3E,F
.................... 	 while (settling_time < 12+Fixlampid);     // priority 
0310:  MOVF   3B,W
0311:  SUBLW  0C
0312:  BTFSC  03.0
0313:  GOTO   310
....................      disable_interrupts(global); 
0314:  BCF    0B.6
0315:  BCF    0B.7
0316:  BTFSC  0B.7
0317:  GOTO   315
....................      txmit1();        // start bit   
0318:  CALL   29A
....................      for(i=0;i<j;i++) 
0319:  CLRF   3C
031A:  MOVF   3E,W
031B:  SUBWF  3C,W
031C:  BTFSC  03.0
031D:  GOTO   36B
....................          { 
....................             if (shift_left(tx_buffer,3,1)==1) 
031E:  BSF    03.0
031F:  RLF    3F,F
0320:  RLF    40,F
0321:  RLF    41,F
0322:  BTFSS  03.0
0323:  GOTO   326
....................             { 
....................                  txmit1(); 
0324:  CALL   29A
....................             } 
0325:  GOTO   367
....................             else 
....................             { 
....................                   txmit0(); 
....................             } 
....................             if (txmit_error ==1) 
*
0367:  BTFSC  31.6
....................             { 
.................... 			//	output_low(pin_c3); 
....................                goto rr; 
0368:  GOTO   36F
....................             }		 
0369:  INCF   3C,F
036A:  GOTO   31A
....................          }         
....................      stopbit();     
036B:  CALL   2ED
....................      stopbit();  
036C:  CALL   2ED
.................... 	stopbit(); stopbit(); 
036D:  CALL   2ED
036E:  CALL   2ED
.................... rr:  output_bit(tx,1); 
036F:  BSF    05.0
0370:  BSF    03.5
0371:  BCF    05.0
.................... 	 settling_time = 0; 
0372:  BCF    03.5
0373:  CLRF   3B
....................      intf =0; 
0374:  BCF    0B.1
....................      enable_interrupts(global);	 
0375:  MOVLW  C0
0376:  IORWF  0B,F
.................... 	 enable_interrupts(INT_RTCC); 
0377:  BSF    0B.5
....................      return; 
0378:  RETURN
.................... } 
....................  
.................... //-------------------------------------------------------------------------- 
....................           // stop bit function // 
.................... //-------------------------------------------------------------------------- 
.................... void  stopbit(void) 
.................... { 
....................       output_bit(tx,1); 
*
02ED:  BSF    05.0
02EE:  BSF    03.5
02EF:  BCF    05.0
.................... 	  //restart_wdt();  
....................       delay_us(830); 
02F0:  MOVLW  05
02F1:  BCF    03.5
02F2:  MOVWF  67
02F3:  MOVLW  A3
02F4:  MOVWF  68
*
0307:  DECFSZ 67,F
0308:  GOTO   2F3
....................       return; 
0309:  RETURN
.................... } 
....................  
.................... //-------------------------------------------------------------------------- 
....................  
....................  
.................... void readData(void) 
.................... { 
.................... 	//restart_wdt();  
....................       error_flag=0; 
*
00C3:  BCF    31.4
....................       datacount++; 
00C4:  INCF   32,F
....................       forwrdFrameFlag = 0; 
00C5:  BCF    4C.0
.................... 	  backwardFrameFlag =0; 
00C6:  BCF    4C.1
....................       if(datacount< 27) 
00C7:  MOVF   32,W
00C8:  SUBLW  1A
00C9:  BTFSS  03.0
00CA:  GOTO   12E
....................       { 
....................          if((a==0 )&& (b==1)) 
00CB:  BTFSC  31.1
00CC:  GOTO   0D4
00CD:  BTFSS  31.3
00CE:  GOTO   0D4
....................          { 
....................             shift_left(data,3,1);  // a one  detewcted on bus  
00CF:  BSF    03.0
00D0:  RLF    33,F
00D1:  RLF    34,F
00D2:  RLF    35,F
....................          } 
00D3:  GOTO   12D
....................          else if((a==1)&&(b==0)) 
00D4:  BTFSS  31.1
00D5:  GOTO   0DD
00D6:  BTFSC  31.3
00D7:  GOTO   0DD
....................          { 
....................             shift_left(data,3,0);  // a zero is  deted on the bus  
00D8:  BCF    03.0
00D9:  RLF    33,F
00DA:  RLF    34,F
00DB:  RLF    35,F
....................          } 
00DC:  GOTO   12D
....................          else if ( a==1 && b==1) 
00DD:  BTFSS  31.1
00DE:  GOTO   124
00DF:  BTFSS  31.3
00E0:  GOTO   124
....................          { 
....................             switch (datacount) 
00E1:  MOVF   32,W
00E2:  XORLW  11
00E3:  BTFSC  03.2
00E4:  GOTO   0EF
00E5:  XORLW  03
00E6:  BTFSC  03.2
00E7:  GOTO   0F1
00E8:  XORLW  0B
00E9:  BTFSC  03.2
00EA:  GOTO   105
00EB:  XORLW  03
00EC:  BTFSC  03.2
00ED:  GOTO   107
00EE:  GOTO   11A
....................             { 
....................                case 17: 
....................                { 
....................                      stopBitCount ++; 
00EF:  INCF   48,F
....................                      break; 
00F0:  GOTO   123
....................                } 
....................                case 18: 
....................                { 
....................                   stopBitCount ++; 
00F1:  INCF   48,F
....................                   if(stopBitCount == 2) 
00F2:  MOVF   48,W
00F3:  SUBLW  02
00F4:  BTFSS  03.2
00F5:  GOTO   0FD
....................                   { 
....................                         r_a=1;  
00F6:  MOVLW  01
00F7:  MOVWF  42
....................                         copyData(); 
00F8:  CALL   059
....................                         forwrdFrameFlag = 1; 
00F9:  BSF    4C.0
....................                         masterflag = 0; 
00FA:  BCF    4C.2
....................                         backwardFrameFlag =0; 
00FB:  BCF    4C.1
....................  
....................                   } 
00FC:  GOTO   104
....................                   else 
....................                   { 
.................... 						error_flag =1; 
00FD:  BSF    31.4
.................... 						clear_interrupt(int_ext); 
00FE:  BCF    0B.1
.................... 						enable_interrupts(INT_EXT); 
00FF:  BSF    0B.4
....................     				  disable_interrupts(int_timer1); 
0100:  BSF    03.5
0101:  BCF    0C.0
....................     		          enable_interrupts(INT_RTCC); 
0102:  BCF    03.5
0103:  BSF    0B.5
....................                   } 
....................                   break; 
0104:  GOTO   123
....................                } 
....................               	case 25: 
.................... 				{ 
.................... 					stopBitCount ++; 
0105:  INCF   48,F
.................... 					break; 
0106:  GOTO   123
.................... 				} 
....................               	case 26:  
.................... 				{ 
.................... 					stopBitCount ++; 
0107:  INCF   48,F
.................... 					if(stopBitCount == 2) 
0108:  MOVF   48,W
0109:  SUBLW  02
010A:  BTFSS  03.2
010B:  GOTO   112
.................... 					{ 
.................... 						r_a=0;  
010C:  CLRF   42
.................... 						copyData(); 
010D:  CALL   059
.................... 						forwrdFrameFlag =0; 
010E:  BCF    4C.0
.................... 						masterflag = 1; 
010F:  BSF    4C.2
.................... 						backwardFrameFlag =0; 
0110:  BCF    4C.1
.................... 					} 
0111:  GOTO   119
.................... 					else 
.................... 					{ 
.................... 						error_flag =1; 
0112:  BSF    31.4
.................... 						clear_interrupt(int_ext); 
0113:  BCF    0B.1
.................... 						enable_interrupts(INT_EXT); 
0114:  BSF    0B.4
....................     				  disable_interrupts(int_timer1); 
0115:  BSF    03.5
0116:  BCF    0C.0
....................     		          enable_interrupts(INT_RTCC); 
0117:  BCF    03.5
0118:  BSF    0B.5
.................... 					} 
.................... 					break; 
0119:  GOTO   123
.................... 				} 
....................                 default: 
....................                 { 
....................                       error_flag=1; 
011A:  BSF    31.4
....................                       timerOnOff=0; 
011B:  BCF    10.0
.................... 					  clear_interrupt(int_ext); 
011C:  BCF    0B.1
....................                       enable_interrupts(INT_EXT); 
011D:  BSF    0B.4
....................     				  disable_interrupts(int_timer1); 
011E:  BSF    03.5
011F:  BCF    0C.0
....................     		          enable_interrupts(INT_RTCC); 
0120:  BCF    03.5
0121:  BSF    0B.5
....................                       settling_time = 0; 
0122:  CLRF   3B
....................                       break; 
....................                 } 
....................              }    
....................           }  
0123:  GOTO   12D
.................... 		else 
.................... 		{ 
.................... 			error_flag=1;     
0124:  BSF    31.4
.................... 			settling_time = 0; 
0125:  CLRF   3B
.................... 			timerOnOff=0;     
0126:  BCF    10.0
.................... 			clear_interrupt(int_ext);    
0127:  BCF    0B.1
.................... 			enable_interrupts(INT_EXT); 
0128:  BSF    0B.4
....................     		disable_interrupts(int_timer1); 
0129:  BSF    03.5
012A:  BCF    0C.0
....................     		enable_interrupts(INT_RTCC);          
012B:  BCF    03.5
012C:  BSF    0B.5
.................... 		} 
....................       } 
012D:  GOTO   137
.................... 	else  // the  data count grater than 27  
.................... 	{ 
.................... 		over_flowflag =1 ; 
012E:  BSF    31.5
.................... 		settling_time = 0; 
012F:  CLRF   3B
.................... 		timerOnOff=0;    
0130:  BCF    10.0
.................... 		clear_interrupt(int_ext);     
0131:  BCF    0B.1
.................... 		enable_interrupts(INT_EXT); 
0132:  BSF    0B.4
....................         disable_interrupts(int_timer1); 
0133:  BSF    03.5
0134:  BCF    0C.0
....................         enable_interrupts(INT_RTCC);         
0135:  BCF    03.5
0136:  BSF    0B.5
.................... 	} 
....................     return; 
.................... } 
....................  
....................  
....................  
....................  
.................... void copyData(void) 
.................... {  
.................... 	dataReady =1;     
*
0059:  BSF    31.7
.................... 	if( r_a==1) 
005A:  DECFSZ 42,W
005B:  GOTO   061
.................... 	{ 
.................... 		address = data[1]; 
005C:  MOVF   34,W
005D:  MOVWF  49
.................... 		command =data[0];						 
005E:  MOVF   33,W
005F:  MOVWF  4A
.................... 	} 
0060:  GOTO   06A
.................... 	else if( r_a==0) 
0061:  MOVF   42,F
0062:  BTFSS  03.2
0063:  GOTO   06A
.................... 	{	 
.................... 		address = data[2]; 
0064:  MOVF   35,W
0065:  MOVWF  49
.................... 		command =data[1]; 
0066:  MOVF   34,W
0067:  MOVWF  4A
.................... 		databyte=data[0];  
0068:  MOVF   33,W
0069:  MOVWF  4B
.................... 	}        
....................     timerOnOff=0; 
006A:  BCF    10.0
....................     intf =0; 
006B:  BCF    0B.1
.................... 	clear_interrupt(int_ext); 
006C:  BCF    0B.1
....................     enable_interrupts(INT_EXT); 
006D:  BSF    0B.4
....................     disable_interrupts(int_timer1); 
006E:  BSF    03.5
006F:  BCF    0C.0
....................     enable_interrupts(INT_RTCC); 
0070:  BCF    03.5
0071:  BSF    0B.5
....................     settling_time = 0; 
0072:  CLRF   3B
....................     return; 
0073:  RETURN
.................... } 
....................  
....................  
.................... void commands(void) 
.................... {  
.................... 	command_st =0;	 
*
0379:  CLRF   45
.................... 	switch(command) 
037A:  MOVF   4A,W
037B:  XORLW  C9
037C:  BTFSC  03.2
037D:  GOTO   3C4
037E:  XORLW  19
037F:  BTFSC  03.2
0380:  GOTO   3E1
0381:  XORLW  04
0382:  BTFSC  03.2
0383:  GOTO   3F3
0384:  XORLW  0C
0385:  BTFSC  03.2
0386:  GOTO   3FA
0387:  XORLW  29
0388:  BTFSC  03.2
0389:  GOTO   3FA
038A:  XORLW  2D
038B:  BTFSC  03.2
038C:  GOTO   405
038D:  XORLW  2C
038E:  BTFSC  03.2
038F:  GOTO   405
0390:  XORLW  1A
0391:  BTFSC  03.2
0392:  GOTO   410
0393:  XORLW  0D
0394:  BTFSC  03.2
0395:  GOTO   435
0396:  XORLW  EE
0397:  BTFSC  03.2
0398:  GOTO   45D
0399:  XORLW  2B
039A:  BTFSC  03.2
039B:  GOTO   520
039C:  XORLW  01
039D:  BTFSC  03.2
039E:  GOTO   544
039F:  XORLW  07
03A0:  BTFSC  03.2
03A1:  GOTO   549
03A2:  XORLW  01
03A3:  BTFSC  03.2
03A4:  GOTO   570
03A5:  XORLW  03
03A6:  BTFSC  03.2
03A7:  GOTO   579
03A8:  XORLW  01
03A9:  BTFSC  03.2
03AA:  GOTO   588
03AB:  XORLW  16
03AC:  BTFSC  03.2
03AD:  GOTO   596
03AE:  XORLW  03
03AF:  BTFSC  03.2
03B0:  GOTO   59F
03B1:  XORLW  01
03B2:  BTFSC  03.2
03B3:  GOTO   5AE
03B4:  XORLW  19
03B5:  BTFSC  03.2
03B6:  GOTO   5BD
03B7:  XORLW  01
03B8:  BTFSC  03.2
03B9:  GOTO   5DD
03BA:  XORLW  1B
03BB:  BTFSC  03.2
03BC:  GOTO   5FD
03BD:  XORLW  04
03BE:  BTFSC  03.2
03BF:  GOTO   5FF
03C0:  XORLW  01
03C1:  BTFSC  03.2
03C2:  GOTO   60E
03C3:  GOTO   62D
.................... 	{ 
.................... 	   	case 201:	// goto  level  
.................... 		{   
.................... 			 
.................... 			if(databyte>= MaximumLevel ) 
03C4:  MOVF   55,W
03C5:  SUBWF  4B,W
03C6:  BTFSS  03.0
03C7:  GOTO   3CF
.................... 			{ 
.................... 				output_high(pin_c2); 
03C8:  BSF    03.5
03C9:  BCF    07.2
03CA:  BCF    03.5
03CB:  BSF    07.2
.................... 				duty = MaximumLevel;				 
03CC:  MOVF   55,W
03CD:  MOVWF  38
.................... 			} 
03CE:  GOTO   3DF
.................... 			else if(databyte<= MinimumLevel ) 
03CF:  MOVF   4B,W
03D0:  SUBWF  54,W
03D1:  BTFSS  03.0
03D2:  GOTO   3D9
.................... 		    { 
.................... 				output_low(pin_c2); 
03D3:  BSF    03.5
03D4:  BCF    07.2
03D5:  BCF    03.5
03D6:  BCF    07.2
.................... 				duty = 0;								 
03D7:  CLRF   38
.................... 			} 
03D8:  GOTO   3DF
.................... 			else 
.................... 			{ 
.................... 				output_high(pin_c2)	; 
03D9:  BSF    03.5
03DA:  BCF    07.2
03DB:  BCF    03.5
03DC:  BSF    07.2
.................... 				duty =databyte;							 
03DD:  MOVF   4B,W
03DE:  MOVWF  38
.................... 			} 		 
.................... 			lamp_on();										 
03DF:  CALL   26A
.................... 			break; 
03E0:  GOTO   62F
.................... 		} 
.................... 		case 208:	// on 
.................... 		{   
.................... 			restart_delay=3000; 
03E1:  CLRF   62
03E2:  CLRF   61
03E3:  MOVLW  0B
03E4:  MOVWF  60
03E5:  MOVLW  B8
03E6:  MOVWF  5F
.................... 			restart_count=0; 
03E7:  CLRF   5E
03E8:  CLRF   5D
03E9:  CLRF   5C
03EA:  CLRF   5B
.................... 			output_high(pin_c2);			 
03EB:  BSF    03.5
03EC:  BCF    07.2
03ED:  BCF    03.5
03EE:  BSF    07.2
.................... 			duty = MaximumLevel; 
03EF:  MOVF   55,W
03F0:  MOVWF  38
.................... 			lamp_on();								 
03F1:  CALL   26A
.................... 			break; 
03F2:  GOTO   62F
.................... 		} 
.................... 		case 212:	//off 
.................... 		{   
.................... 			output_low(pin_c2); 
03F3:  BSF    03.5
03F4:  BCF    07.2
03F5:  BCF    03.5
03F6:  BCF    07.2
.................... 			duty =0; 
03F7:  CLRF   38
.................... 			lamp_off(); 
03F8:  CALL   266
.................... 			break; 
03F9:  GOTO   62F
.................... 		} 
.................... 		case 216:	//dim 
.................... 		case 241:		//ZONE DIM 
.................... 		{ 
.................... 			if(l_st==1) 
03FA:  DECFSZ 44,W
03FB:  GOTO   404
.................... 			{				 
.................... 				if(duty>MinimumLevel) 
03FC:  MOVF   38,W
03FD:  SUBWF  54,W
03FE:  BTFSC  03.0
03FF:  GOTO   404
.................... 				{							 
.................... 					duty--; 
0400:  DECF   38,F
.................... 					SetDimmLevel(duty);					 
0401:  MOVF   38,W
0402:  MOVWF  65
0403:  CALL   21A
.................... 				} 
.................... 			} 
.................... 			break; 
0404:  GOTO   62F
.................... 		} 
.................... 		case 220:	//bright					 
.................... 		case 240:  //zone  bright 
.................... 		{ 
.................... 			if(l_st==1) 
0405:  DECFSZ 44,W
0406:  GOTO   40F
.................... 			{			 
.................... 				if(duty < MaximumLevel) 
0407:  MOVF   55,W
0408:  SUBWF  38,W
0409:  BTFSC  03.0
040A:  GOTO   40F
.................... 				{									 
.................... 					duty++; 
040B:  INCF   38,F
.................... 					SetDimmLevel(duty);			 
040C:  MOVF   38,W
040D:  MOVWF  65
040E:  CALL   21A
.................... 				} 
.................... 			} 
.................... 			break; 
040F:  GOTO   62F
.................... 		}	 
.................... 	 
.................... 		case 234: // scene select  
.................... 		{				 
.................... 			if(databyte < 17) 
0410:  MOVF   4B,W
0411:  SUBLW  10
0412:  BTFSS  03.0
0413:  GOTO   434
.................... 			{				 
.................... 				currentSceen = databyte;			 
0414:  MOVF   4B,W
0415:  MOVWF  43
.................... 		        duty = read_EEPROM (currentSceen+SceneStore);	 
0416:  MOVLW  06
0417:  ADDWF  43,W
0418:  MOVWF  65
0419:  MOVF   65,W
041A:  BSF    03.5
041B:  MOVWF  1B
041C:  BCF    1C.7
041D:  BSF    1C.0
041E:  MOVF   1A,W
041F:  BCF    03.5
0420:  MOVWF  38
.................... 			     	if(duty<=MinimumLevel) 
0421:  MOVF   38,W
0422:  SUBWF  54,W
0423:  BTFSS  03.0
0424:  GOTO   42C
.................... 					{ 
.................... 						duty=0; 
0425:  CLRF   38
.................... 						output_low(pin_c2);				 
0426:  BSF    03.5
0427:  BCF    07.2
0428:  BCF    03.5
0429:  BCF    07.2
.................... 						lamp_off();		 
042A:  CALL   266
.................... 					} 
042B:  GOTO   434
.................... 					else 
.................... 					{	 
.................... 						output_high(pin_c2);								 
042C:  BSF    03.5
042D:  BCF    07.2
042E:  BCF    03.5
042F:  BSF    07.2
.................... 						lamp_on();	 
0430:  CALL   26A
.................... 						SetDimmLevel(duty);		 
0431:  MOVF   38,W
0432:  MOVWF  65
0433:  CALL   21A
.................... 					}			 
.................... 			} 
.................... 			break; 
0434:  GOTO   62F
.................... 		 } 
.................... 		case 231:  // store sceen  
.................... 		{ 
.................... 			if(databyte < 17) 
0435:  MOVF   4B,W
0436:  SUBLW  10
0437:  BTFSS  03.0
0438:  GOTO   45C
.................... 			{				 
.................... 				disable_interrupts (global); 
0439:  BCF    0B.6
043A:  BCF    0B.7
043B:  BTFSC  0B.7
043C:  GOTO   43A
.................... 				write_eeprom(databyte+SceneStore,duty); 
043D:  MOVLW  06
043E:  ADDWF  4B,W
043F:  MOVWF  65
0440:  MOVF   0B,W
0441:  MOVWF  20
0442:  BCF    0B.7
0443:  MOVF   65,W
0444:  BSF    03.5
0445:  MOVWF  1B
0446:  BCF    03.5
0447:  MOVF   38,W
0448:  BSF    03.5
0449:  MOVWF  1A
044A:  BCF    1C.7
044B:  BSF    1C.2
044C:  MOVLW  55
044D:  MOVWF  1D
044E:  MOVLW  AA
044F:  MOVWF  1D
0450:  BSF    1C.1
0451:  BTFSC  1C.1
0452:  GOTO   451
0453:  BCF    1C.2
0454:  BCF    03.5
0455:  MOVF   20,W
0456:  IORWF  0B,F
.................... 				delay_us(5);			 
0457:  GOTO   458
0458:  GOTO   459
0459:  NOP
.................... 				enable_interrupts(global);	 
045A:  MOVLW  C0
045B:  IORWF  0B,F
.................... 			} 
.................... 			break; 
045C:  GOTO   62F
.................... 		} 
.................... 		case 9: 
.................... 		{		 
.................... 				GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
045D:  MOVLW  05
045E:  BSF    03.5
045F:  MOVWF  1B
0460:  BCF    1C.7
0461:  BSF    1C.0
0462:  MOVF   1A,W
0463:  BCF    03.5
0464:  MOVWF  65
0465:  MOVLW  04
0466:  BSF    03.5
0467:  MOVWF  1B
0468:  BCF    1C.7
0469:  BSF    1C.0
046A:  MOVF   1A,W
046B:  BCF    03.5
046C:  MOVWF  66
046D:  MOVF   65,W
046E:  MOVWF  50
046F:  MOVF   66,W
0470:  MOVWF  4F
.................... 				gindex = databyte &0x0f;				 
0471:  MOVF   4B,W
0472:  ANDLW  0F
0473:  MOVWF  51
.................... 				switch (databyte & 0x10) 
0474:  MOVF   4B,W
0475:  ANDLW  10
0476:  BTFSC  03.2
0477:  GOTO   47C
0478:  XORLW  10
0479:  BTFSC  03.2
047A:  GOTO   4D0
047B:  GOTO   51F
.................... 				{ 
.................... 					case 0: 
.................... 						{ 
.................... 							bit_clear(GroupSelectReg,gindex); 
047C:  CLRF   23
047D:  MOVLW  01
047E:  MOVWF  22
047F:  MOVF   51,W
0480:  MOVWF  20
0481:  BTFSC  03.2
0482:  GOTO   488
0483:  BCF    03.0
0484:  RLF    22,F
0485:  RLF    23,F
0486:  DECFSZ 20,F
0487:  GOTO   483
0488:  MOVF   22,W
0489:  XORLW  FF
048A:  MOVWF  20
048B:  MOVLW  FF
048C:  XORWF  23,F
048D:  MOVF   20,W
048E:  ANDWF  4F,F
048F:  MOVF   23,W
0490:  ANDWF  50,F
.................... 							write_eeprom(Group_07Store  ,make8(GroupSelectReg,0)); 
0491:  MOVF   4F,W
0492:  MOVWF  65
0493:  MOVF   0B,W
0494:  MOVWF  20
0495:  BCF    0B.7
0496:  MOVLW  04
0497:  BSF    03.5
0498:  MOVWF  1B
0499:  BCF    03.5
049A:  MOVF   4F,W
049B:  BSF    03.5
049C:  MOVWF  1A
049D:  BCF    1C.7
049E:  BSF    1C.2
049F:  MOVLW  55
04A0:  MOVWF  1D
04A1:  MOVLW  AA
04A2:  MOVWF  1D
04A3:  BSF    1C.1
04A4:  BTFSC  1C.1
04A5:  GOTO   4A4
04A6:  BCF    1C.2
04A7:  BCF    03.5
04A8:  MOVF   20,W
04A9:  IORWF  0B,F
.................... 							delay_us(10); 
04AA:  MOVLW  02
04AB:  MOVWF  20
04AC:  DECFSZ 20,F
04AD:  GOTO   4AC
04AE:  GOTO   4AF
04AF:  NOP
.................... 							write_eeprom(Group_815Store,make8(GroupSelectReg,1)); 
04B0:  MOVF   50,W
04B1:  MOVWF  65
04B2:  MOVF   0B,W
04B3:  MOVWF  20
04B4:  BCF    0B.7
04B5:  MOVLW  05
04B6:  BSF    03.5
04B7:  MOVWF  1B
04B8:  BCF    03.5
04B9:  MOVF   50,W
04BA:  BSF    03.5
04BB:  MOVWF  1A
04BC:  BCF    1C.7
04BD:  BSF    1C.2
04BE:  MOVLW  55
04BF:  MOVWF  1D
04C0:  MOVLW  AA
04C1:  MOVWF  1D
04C2:  BSF    1C.1
04C3:  BTFSC  1C.1
04C4:  GOTO   4C3
04C5:  BCF    1C.2
04C6:  BCF    03.5
04C7:  MOVF   20,W
04C8:  IORWF  0B,F
....................  							delay_us(10); 
04C9:  MOVLW  02
04CA:  MOVWF  20
04CB:  DECFSZ 20,F
04CC:  GOTO   4CB
04CD:  GOTO   4CE
04CE:  NOP
.................... 							break; 
04CF:  GOTO   51F
.................... 						} 
.................... 					case 16: 
.................... 						{ 
.................... 							bit_set(GroupSelectReg,gindex); 
04D0:  CLRF   23
04D1:  MOVLW  01
04D2:  MOVWF  22
04D3:  MOVF   51,W
04D4:  MOVWF  20
04D5:  BTFSC  03.2
04D6:  GOTO   4DC
04D7:  BCF    03.0
04D8:  RLF    22,F
04D9:  RLF    23,F
04DA:  DECFSZ 20,F
04DB:  GOTO   4D7
04DC:  MOVF   22,W
04DD:  IORWF  4F,F
04DE:  MOVF   23,W
04DF:  IORWF  50,F
.................... 							write_eeprom(Group_07Store  ,make8(GroupSelectReg,0)); 
04E0:  MOVF   4F,W
04E1:  MOVWF  65
04E2:  MOVF   0B,W
04E3:  MOVWF  20
04E4:  BCF    0B.7
04E5:  MOVLW  04
04E6:  BSF    03.5
04E7:  MOVWF  1B
04E8:  BCF    03.5
04E9:  MOVF   4F,W
04EA:  BSF    03.5
04EB:  MOVWF  1A
04EC:  BCF    1C.7
04ED:  BSF    1C.2
04EE:  MOVLW  55
04EF:  MOVWF  1D
04F0:  MOVLW  AA
04F1:  MOVWF  1D
04F2:  BSF    1C.1
04F3:  BTFSC  1C.1
04F4:  GOTO   4F3
04F5:  BCF    1C.2
04F6:  BCF    03.5
04F7:  MOVF   20,W
04F8:  IORWF  0B,F
.................... 							delay_us(10); 
04F9:  MOVLW  02
04FA:  MOVWF  20
04FB:  DECFSZ 20,F
04FC:  GOTO   4FB
04FD:  GOTO   4FE
04FE:  NOP
.................... 							write_eeprom(Group_815Store,make8(GroupSelectReg,1)); 
04FF:  MOVF   50,W
0500:  MOVWF  65
0501:  MOVF   0B,W
0502:  MOVWF  20
0503:  BCF    0B.7
0504:  MOVLW  05
0505:  BSF    03.5
0506:  MOVWF  1B
0507:  BCF    03.5
0508:  MOVF   50,W
0509:  BSF    03.5
050A:  MOVWF  1A
050B:  BCF    1C.7
050C:  BSF    1C.2
050D:  MOVLW  55
050E:  MOVWF  1D
050F:  MOVLW  AA
0510:  MOVWF  1D
0511:  BSF    1C.1
0512:  BTFSC  1C.1
0513:  GOTO   512
0514:  BCF    1C.2
0515:  BCF    03.5
0516:  MOVF   20,W
0517:  IORWF  0B,F
....................  							delay_us(10); 
0518:  MOVLW  02
0519:  MOVWF  20
051A:  DECFSZ 20,F
051B:  GOTO   51A
051C:  GOTO   51D
051D:  NOP
.................... 							break; 
051E:  GOTO   51F
.................... 						} 
.................... 					 
.................... 					default: break; 
....................  
.................... 				} 
.................... 				break ; 
051F:  GOTO   62F
.................... 		} 
.................... 		case 34:    // store  short  aress  
.................... 		{ 
.................... 			if(databyte <64) 
0520:  MOVF   4B,W
0521:  SUBLW  3F
0522:  BTFSS  03.0
0523:  GOTO   543
.................... 			{ 
.................... 					lampid = databyte; 
0524:  MOVF   4B,W
0525:  MOVWF  5A
.................... 					write_eeprom(ShortAddressStore ,lampid); 
0526:  MOVF   0B,W
0527:  MOVWF  20
0528:  BCF    0B.7
0529:  MOVLW  03
052A:  BSF    03.5
052B:  MOVWF  1B
052C:  BCF    03.5
052D:  MOVF   5A,W
052E:  BSF    03.5
052F:  MOVWF  1A
0530:  BCF    1C.7
0531:  BSF    1C.2
0532:  MOVLW  55
0533:  MOVWF  1D
0534:  MOVLW  AA
0535:  MOVWF  1D
0536:  BSF    1C.1
0537:  BTFSC  1C.1
0538:  GOTO   537
0539:  BCF    1C.2
053A:  BCF    03.5
053B:  MOVF   20,W
053C:  IORWF  0B,F
.................... 					delay_us(10); 
053D:  MOVLW  02
053E:  MOVWF  20
053F:  DECFSZ 20,F
0540:  GOTO   53F
0541:  GOTO   542
0542:  NOP
.................... 			} 
.................... 		 
.................... 			break;		 
0543:  GOTO   62F
.................... 		} 
.................... 		case 35:    // write  DTR  
.................... 		{ 
.................... 					DTR = databyte;	 
0544:  MOVF   4B,W
0545:  MOVWF  57
.................... 					DTR_Ready =1; 
0546:  MOVLW  01
0547:  MOVWF  59
.................... 					break; 
0548:  GOTO   62F
.................... 		} 
.................... 		case 36:    // write  DTR  to  adress  location  in data  byte  
.................... 		{ 
.................... 					 
.................... 				DwriteLocation = databyte;	 
0549:  MOVF   4B,W
054A:  MOVWF  58
.................... 				if(DTR_Ready ==1 && DwriteLocation<33 ) 
054B:  DECFSZ 59,W
054C:  GOTO   56E
054D:  MOVF   58,W
054E:  SUBLW  20
054F:  BTFSS  03.0
0550:  GOTO   56E
.................... 				{ 
.................... 					DTR_Ready =0; 
0551:  CLRF   59
.................... 					write_eeprom(DwriteLocation,DTR); 
0552:  MOVF   0B,W
0553:  MOVWF  20
0554:  BCF    0B.7
0555:  MOVF   58,W
0556:  BSF    03.5
0557:  MOVWF  1B
0558:  BCF    03.5
0559:  MOVF   57,W
055A:  BSF    03.5
055B:  MOVWF  1A
055C:  BCF    1C.7
055D:  BSF    1C.2
055E:  MOVLW  55
055F:  MOVWF  1D
0560:  MOVLW  AA
0561:  MOVWF  1D
0562:  BSF    1C.1
0563:  BTFSC  1C.1
0564:  GOTO   563
0565:  BCF    1C.2
0566:  BCF    03.5
0567:  MOVF   20,W
0568:  IORWF  0B,F
.................... 					DELAY_US(20); 
0569:  MOVLW  06
056A:  MOVWF  20
056B:  DECFSZ 20,F
056C:  GOTO   56B
056D:  NOP
.................... 				} 
.................... 			init_from_eeprom(); 
056E:  CALL   15F
.................... 			break; 
056F:  GOTO   62F
.................... 		} 
.................... 		case 37:    // Read  DTR  to  adress  location  in data  byte  
.................... 		{ 
.................... 				tx_buffer[2]=lampid;tx_buffer[1]=DTR; txmit(2,2);  /////////priority changed 
0570:  MOVF   5A,W
0571:  MOVWF  41
0572:  MOVF   57,W
0573:  MOVWF  40
0574:  MOVLW  02
0575:  MOVWF  65
0576:  MOVWF  66
0577:  CALL   30A
.................... 				break;			 
0578:  GOTO   62F
.................... 		} 
.................... 		case 38:    // Read  eeprom  and  store  in dtr   to  adress  location  in data  byte  
.................... 		{ 
.................... 				DwriteLocation = databyte;	 
0579:  MOVF   4B,W
057A:  MOVWF  58
.................... 				if( DwriteLocation<33 ) 
057B:  MOVF   58,W
057C:  SUBLW  20
057D:  BTFSS  03.0
057E:  GOTO   587
.................... 				{ 
.................... 					DTR=Read_eeprom(DwriteLocation); 
057F:  MOVF   58,W
0580:  BSF    03.5
0581:  MOVWF  1B
0582:  BCF    1C.7
0583:  BSF    1C.0
0584:  MOVF   1A,W
0585:  BCF    03.5
0586:  MOVWF  57
.................... 				}	 
.................... 				break;				 
0587:  GOTO   62F
.................... 		} 
.................... 		case 39:	// Query current device power level 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=Read_eeprom(0);  
0588:  MOVF   5A,W
0589:  MOVWF  41
058A:  BSF    03.5
058B:  CLRF   1B
058C:  BCF    1C.7
058D:  BSF    1C.0
058E:  MOVF   1A,W
058F:  BCF    03.5
0590:  MOVWF  40
.................... 	    	txmit(2,2);		 
0591:  MOVLW  02
0592:  MOVWF  65
0593:  MOVWF  66
0594:  CALL   30A
.................... 			break; 
0595:  GOTO   62F
....................  
.................... 		} 
.................... 		case 49: 	// case for device type query 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=device_type;  
0596:  MOVF   5A,W
0597:  MOVWF  41
0598:  MOVLW  07
0599:  MOVWF  40
.................... 			txmit(2,2);			 
059A:  MOVLW  02
059B:  MOVWF  65
059C:  MOVWF  66
059D:  CALL   30A
.................... 			break; 
059E:  GOTO   62F
....................  
.................... 		} 
.................... 		case 50: 	// case for first group secion query  
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=Read_eeprom(7);  
059F:  MOVF   5A,W
05A0:  MOVWF  41
05A1:  MOVLW  07
05A2:  BSF    03.5
05A3:  MOVWF  1B
05A4:  BCF    1C.7
05A5:  BSF    1C.0
05A6:  MOVF   1A,W
05A7:  BCF    03.5
05A8:  MOVWF  40
.................... 			txmit(2,2);			 
05A9:  MOVLW  02
05AA:  MOVWF  65
05AB:  MOVWF  66
05AC:  CALL   30A
.................... 			break; 
05AD:  GOTO   62F
....................  
.................... 		} 
.................... 		case 51: 	// case for second group secion query  
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=Read_eeprom(8);  
05AE:  MOVF   5A,W
05AF:  MOVWF  41
05B0:  MOVLW  08
05B1:  BSF    03.5
05B2:  MOVWF  1B
05B3:  BCF    1C.7
05B4:  BSF    1C.0
05B5:  MOVF   1A,W
05B6:  BCF    03.5
05B7:  MOVWF  40
.................... 			txmit(2,2);			 
05B8:  MOVLW  02
05B9:  MOVWF  65
05BA:  MOVWF  66
05BB:  CALL   30A
.................... 			break; 
05BC:  GOTO   62F
....................  
.................... 		} 
.................... 		case 42: 	// setting max level  
.................... 		{ 
.................... 			MaximumLevel=databyte; 
05BD:  MOVF   4B,W
05BE:  MOVWF  55
.................... 			write_eeprom(MaximumLevelStore,MaximumLevel); 
05BF:  MOVF   0B,W
05C0:  MOVWF  20
05C1:  BCF    0B.7
05C2:  MOVLW  02
05C3:  BSF    03.5
05C4:  MOVWF  1B
05C5:  BCF    03.5
05C6:  MOVF   55,W
05C7:  BSF    03.5
05C8:  MOVWF  1A
05C9:  BCF    1C.7
05CA:  BSF    1C.2
05CB:  MOVLW  55
05CC:  MOVWF  1D
05CD:  MOVLW  AA
05CE:  MOVWF  1D
05CF:  BSF    1C.1
05D0:  BTFSC  1C.1
05D1:  GOTO   5D0
05D2:  BCF    1C.2
05D3:  BCF    03.5
05D4:  MOVF   20,W
05D5:  IORWF  0B,F
.................... 			delay_us(10);			 
05D6:  MOVLW  02
05D7:  MOVWF  20
05D8:  DECFSZ 20,F
05D9:  GOTO   5D8
05DA:  GOTO   5DB
05DB:  NOP
.................... 			break; 
05DC:  GOTO   62F
....................  
.................... 		} 
.................... 		case 43: 	// setting min level  
.................... 		{ 
.................... 			MinimumLevel=databyte; 
05DD:  MOVF   4B,W
05DE:  MOVWF  54
.................... 			write_eeprom(MinimumLevelStore,MinimumLevel); 
05DF:  MOVF   0B,W
05E0:  MOVWF  20
05E1:  BCF    0B.7
05E2:  MOVLW  01
05E3:  BSF    03.5
05E4:  MOVWF  1B
05E5:  BCF    03.5
05E6:  MOVF   54,W
05E7:  BSF    03.5
05E8:  MOVWF  1A
05E9:  BCF    1C.7
05EA:  BSF    1C.2
05EB:  MOVLW  55
05EC:  MOVWF  1D
05ED:  MOVLW  AA
05EE:  MOVWF  1D
05EF:  BSF    1C.1
05F0:  BTFSC  1C.1
05F1:  GOTO   5F0
05F2:  BCF    1C.2
05F3:  BCF    03.5
05F4:  MOVF   20,W
05F5:  IORWF  0B,F
.................... 			delay_us(10);		 
05F6:  MOVLW  02
05F7:  MOVWF  20
05F8:  DECFSZ 20,F
05F9:  GOTO   5F8
05FA:  GOTO   5FB
05FB:  NOP
.................... 			break; 
05FC:  GOTO   62F
.................... 		} 
.................... 		case 48:	// PWM Restart operation			 
.................... 		{ 
.................... 			ECCPASE=0;		 
05FD:  BCF    17.7
.................... 			break; 
05FE:  GOTO   62F
.................... 		} 
.................... 		case 52:	// Read the no. of times system was shutdown permanently 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=Read_eeprom(SystemFailureRateStore);  
05FF:  MOVF   5A,W
0600:  MOVWF  41
0601:  MOVLW  19
0602:  BSF    03.5
0603:  MOVWF  1B
0604:  BCF    1C.7
0605:  BSF    1C.0
0606:  MOVF   1A,W
0607:  BCF    03.5
0608:  MOVWF  40
.................... 			txmit(2,2); 
0609:  MOVLW  02
060A:  MOVWF  65
060B:  MOVWF  66
060C:  CALL   30A
.................... 			break; 
060D:  GOTO   62F
.................... 		} 
.................... 		case 53:	// Set current protection threshold value 
.................... 		{ 
.................... 			current_threshold=databyte; 
060E:  MOVF   4B,W
060F:  MOVWF  64
.................... 			write_eeprom(CurrentThresholdStore,current_threshold); 
0610:  MOVF   0B,W
0611:  MOVWF  20
0612:  BCF    0B.7
0613:  MOVLW  1A
0614:  BSF    03.5
0615:  MOVWF  1B
0616:  BCF    03.5
0617:  MOVF   64,W
0618:  BSF    03.5
0619:  MOVWF  1A
061A:  BCF    1C.7
061B:  BSF    1C.2
061C:  MOVLW  55
061D:  MOVWF  1D
061E:  MOVLW  AA
061F:  MOVWF  1D
0620:  BSF    1C.1
0621:  BTFSC  1C.1
0622:  GOTO   621
0623:  BCF    1C.2
0624:  BCF    03.5
0625:  MOVF   20,W
0626:  IORWF  0B,F
.................... 			delay_us(10); 
0627:  MOVLW  02
0628:  MOVWF  20
0629:  DECFSZ 20,F
062A:  GOTO   629
062B:  GOTO   62C
062C:  NOP
.................... 		} 
.................... 		default: 
.................... 		{ 
.................... 			command_st=1; 
062D:  MOVLW  01
062E:  MOVWF  45
.................... 			break; 
.................... 		} 
.................... 	} 
.................... 	if(command_st==0) 
062F:  MOVF   45,F
0630:  BTFSS  03.2
0631:  GOTO   648
.................... 	{ 		 
.................... 		  write_eeprom(PowerOnLevelStore,duty);		 
0632:  MOVF   0B,W
0633:  MOVWF  20
0634:  BCF    0B.7
0635:  BSF    03.5
0636:  CLRF   1B
0637:  BCF    03.5
0638:  MOVF   38,W
0639:  BSF    03.5
063A:  MOVWF  1A
063B:  BCF    1C.7
063C:  BSF    1C.2
063D:  MOVLW  55
063E:  MOVWF  1D
063F:  MOVLW  AA
0640:  MOVWF  1D
0641:  BSF    1C.1
0642:  BTFSC  1C.1
0643:  GOTO   642
0644:  BCF    1C.2
0645:  BCF    03.5
0646:  MOVF   20,W
0647:  IORWF  0B,F
.................... 	} 
.................... 	return; 
.................... } 
....................  
.................... void lamp_on() 
.................... {	 
.................... 	SetDimmLevel(duty); 
*
026A:  MOVF   38,W
026B:  MOVWF  65
026C:  CALL   21A
.................... 	l_st=1; 
026D:  MOVLW  01
026E:  MOVWF  44
.................... 	return; 
026F:  RETURN
.................... } 
.................... 	 
.................... void lamp_off() 
.................... {	 
.................... 	SetDimmLevel(0);	 
*
0266:  CLRF   65
0267:  CALL   21A
.................... 	l_st=0; 
0268:  CLRF   44
.................... 	return; 
0269:  RETURN
.................... } 
....................  
....................  
.................... 	 
.................... void SetDimmLevel(unsigned int dimPesentage) 
.................... { 
.................... 	if(dimPesentage >= MaximumLevel) 
*
021A:  MOVF   55,W
021B:  SUBWF  65,W
021C:  BTFSS  03.0
021D:  GOTO   221
.................... 		{ 
.................... 			dimPesentage = MaximumLevel; 
021E:  MOVF   55,W
021F:  MOVWF  65
.................... 		} 
0220:  GOTO   227
.................... 	else if(dimPesentage <= MinimumLevel) 
0221:  MOVF   65,W
0222:  SUBWF  54,W
0223:  BTFSS  03.0
0224:  GOTO   227
.................... 		{ 
.................... 			dimPesentage = MinimumLevel; 
0225:  MOVF   54,W
0226:  MOVWF  65
.................... 		} 
.................... 	 
.................... 	if(dimPesentage <=MinimumLevel) 
0227:  MOVF   65,W
0228:  SUBWF  54,W
0229:  BTFSS  03.0
022A:  GOTO   230
.................... 		{ 
.................... 			output_low(pin_c2); 
022B:  BSF    03.5
022C:  BCF    07.2
022D:  BCF    03.5
022E:  BCF    07.2
.................... 		} 
022F:  GOTO   234
.................... 	else 
.................... 		{ 
.................... 			output_high(pin_c2); 
0230:  BSF    03.5
0231:  BCF    07.2
0232:  BCF    03.5
0233:  BSF    07.2
.................... 		} 
....................  
.................... 	if(dimPesentage<95) 
0234:  MOVF   65,W
0235:  SUBLW  5E
0236:  BTFSS  03.0
0237:  GOTO   23B
.................... 	{ 
.................... 		Power =dimPesentage; 
0238:  CLRF   3A
0239:  MOVF   65,W
023A:  MOVWF  39
.................... 	} 
.................... 	if(dimPesentage>=95) 
023B:  MOVF   65,W
023C:  SUBLW  5E
023D:  BTFSC  03.0
023E:  GOTO   243
.................... 	{ 
.................... 		Power =1023; 
023F:  MOVLW  03
0240:  MOVWF  3A
0241:  MOVLW  FF
0242:  MOVWF  39
.................... 	} 
.................... 	if(Power > 1020){Power =1023;} 
0243:  MOVF   3A,W
0244:  SUBLW  02
0245:  BTFSC  03.0
0246:  GOTO   252
0247:  XORLW  FF
0248:  BTFSS  03.2
0249:  GOTO   24E
024A:  MOVF   39,W
024B:  SUBLW  FC
024C:  BTFSC  03.0
024D:  GOTO   252
024E:  MOVLW  03
024F:  MOVWF  3A
0250:  MOVLW  FF
0251:  MOVWF  39
.................... 	set_pwm1_duty(Power); 
0252:  MOVF   3A,W
0253:  MOVWF  22
0254:  MOVF   39,W
0255:  MOVWF  21
0256:  RRF    22,F
0257:  RRF    21,F
0258:  RRF    22,F
0259:  RRF    21,F
025A:  RRF    22,F
025B:  MOVF   21,W
025C:  MOVWF  13
025D:  RRF    22,F
025E:  RRF    22,W
025F:  ANDLW  30
0260:  MOVWF  20
0261:  MOVF   15,W
0262:  ANDLW  CF
0263:  IORWF  20,W
0264:  MOVWF  15
0265:  RETURN
.................... 	} 
....................  
....................  
.................... void init_from_eeprom(void) 
.................... { 
.................... GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
*
015F:  MOVLW  05
0160:  BSF    03.5
0161:  MOVWF  1B
0162:  BCF    1C.7
0163:  BSF    1C.0
0164:  MOVF   1A,W
0165:  BCF    03.5
0166:  MOVWF  65
0167:  MOVLW  04
0168:  BSF    03.5
0169:  MOVWF  1B
016A:  BCF    1C.7
016B:  BSF    1C.0
016C:  MOVF   1A,W
016D:  BCF    03.5
016E:  MOVWF  66
016F:  MOVF   65,W
0170:  MOVWF  50
0171:  MOVF   66,W
0172:  MOVWF  4F
.................... delay_us(10); 
0173:  MOVLW  02
0174:  MOVWF  20
0175:  DECFSZ 20,F
0176:  GOTO   175
0177:  GOTO   178
0178:  NOP
.................... PowerOnLevel 		= read_EEPROM (PowerOnLevelStore); 
0179:  BSF    03.5
017A:  CLRF   1B
017B:  BCF    1C.7
017C:  BSF    1C.0
017D:  MOVF   1A,W
017E:  BCF    03.5
017F:  MOVWF  56
.................... delay_us(10);     
0180:  MOVLW  02
0181:  MOVWF  20
0182:  DECFSZ 20,F
0183:  GOTO   182
0184:  GOTO   185
0185:  NOP
.................... MinimumLevel		= read_EEPROM ( MinimumLevelStore );    
0186:  MOVLW  01
0187:  BSF    03.5
0188:  MOVWF  1B
0189:  BCF    1C.7
018A:  BSF    1C.0
018B:  MOVF   1A,W
018C:  BCF    03.5
018D:  MOVWF  54
.................... delay_us(10);       	 
018E:  MOVLW  02
018F:  MOVWF  20
0190:  DECFSZ 20,F
0191:  GOTO   190
0192:  GOTO   193
0193:  NOP
.................... MaximumLevel 		= read_EEPROM ( MaximumLevelStore);  
0194:  MOVLW  02
0195:  BSF    03.5
0196:  MOVWF  1B
0197:  BCF    1C.7
0198:  BSF    1C.0
0199:  MOVF   1A,W
019A:  BCF    03.5
019B:  MOVWF  55
.................... delay_us(10);  	 
019C:  MOVLW  02
019D:  MOVWF  20
019E:  DECFSZ 20,F
019F:  GOTO   19E
01A0:  GOTO   1A1
01A1:  NOP
.................... lampid 				= read_EEPROM ( ShortAddressStore ); 
01A2:  MOVLW  03
01A3:  BSF    03.5
01A4:  MOVWF  1B
01A5:  BCF    1C.7
01A6:  BSF    1C.0
01A7:  MOVF   1A,W
01A8:  BCF    03.5
01A9:  MOVWF  5A
.................... delay_us(10); 
01AA:  MOVLW  02
01AB:  MOVWF  20
01AC:  DECFSZ 20,F
01AD:  GOTO   1AC
01AE:  GOTO   1AF
01AF:  NOP
.................... zoneid=read_EEPROM(zoneidstore); 
01B0:  MOVLW  20
01B1:  BSF    03.5
01B2:  MOVWF  1B
01B3:  BCF    1C.7
01B4:  BSF    1C.0
01B5:  MOVF   1A,W
01B6:  BCF    03.5
01B7:  MOVWF  47
.................... delay_us(10); 
01B8:  MOVLW  02
01B9:  MOVWF  20
01BA:  DECFSZ 20,F
01BB:  GOTO   1BA
01BC:  GOTO   1BD
01BD:  NOP
.................... failure_count=read_EEPROM(SystemFailureRateStore); 
01BE:  MOVLW  19
01BF:  BSF    03.5
01C0:  MOVWF  1B
01C1:  BCF    1C.7
01C2:  BSF    1C.0
01C3:  MOVF   1A,W
01C4:  BCF    03.5
01C5:  MOVWF  63
.................... delay_us(10); 
01C6:  MOVLW  02
01C7:  MOVWF  20
01C8:  DECFSZ 20,F
01C9:  GOTO   1C8
01CA:  GOTO   1CB
01CB:  NOP
.................... current_threshold=read_EEPROM(CurrentThresholdStore); 
01CC:  MOVLW  1A
01CD:  BSF    03.5
01CE:  MOVWF  1B
01CF:  BCF    1C.7
01D0:  BSF    1C.0
01D1:  MOVF   1A,W
01D2:  BCF    03.5
01D3:  MOVWF  64
.................... delay_us(10); 
01D4:  MOVLW  02
01D5:  MOVWF  20
01D6:  DECFSZ 20,F
01D7:  GOTO   1D6
01D8:  GOTO   1D9
01D9:  NOP
01DA:  RETURN
.................... } 
....................  
....................  

Configuration Fuses:
   Word  1: 33EC   INTRC_IO WDT PUT MCLR NOPROTECT NOCPD BROWNOUT NOIESO NOFCMEN

ROM data:
002100: 0064 0000 0064 0001 0001 0000 0000 0014 
002108: 001E 0032 0046 005A 0064 0023 0028 002D 
002110: 004B 0019 003C 0041 005F 0064 

002120: 00D2 
